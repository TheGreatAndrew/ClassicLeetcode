############### GUIDE 
A monotonic stack is a stack whose elements are monotonically increasing or descreasing.
format
    how to do, mistakes, hidden tricks 
Array, Trie, Union Find, sparse table, seg tree, Fenwick tree, Vectors, bit manipulation

############### GENERAL
https://leetcode.com/problems/task-scheduler
https://leetcode.com/problems/is-subsequence/discuss/385275/Easiest-python-solution-(beats-98-%2B-explanation)
    # interesting way of traversal 2 lists
Greatest English Letter in Upper and Lower Case do it myself
https://leetcode.com/problems/happy-number
    my fail -> inteprete the question wrong 
    approach 1 -> just keep going until the set is repeated 
    approach 2 -> niche. Floyd's Cycle-Finding Algorithm. 
https://leetcode.com/problems/count-asterisks/ do it myself 



############### BIG O
https://stackoverflow.com/questions/8929284/what-makes-sets-faster-than-lists 
    set is O(1) because position of an element is determined by hashing set, when you retrieve you hash element again.
    sets aren't faster than lists in general -- membership test is faster for sets, and so is removing an element



############### STRING 
general
    subsequence -> add or remove letters -> 
    anagram -> same letters, different orders -> 
    palindrom -> reverse string and it is the same -> 
    permutation, palindrome, superset -> 
    can be 2 pointers, sliding window


https://leetcode.com/problems/reverse-string/
    for loop. reverse(). [::-1] 
https://leetcode.com/problems/group-anagrams do it myself
    '''
    for each string, we store all letters as Key in Dict to group them 
    speed O(n*l) where n is all strings, l is length of each string + O(n) 
    space O(2n) for dict, res
    '''  
    https://leetcode.com/problems/group-anagrams/discuss/664252/Python-3-solution-detailed-explanation-faster-than-97.5 exatly same solution, but faster and cool technique, and look at comment    









############### ARRAY
### ARRAY GUIDE
patterns : prefix sum, subset backtracking (permutation), sliding window 
### subset backtracking 
https://leetcode.com/problems/letter-combinations-of-a-phone-number/discuss/780232/Backtracking-Python-problems%2B-solutions-interview-prep list






############## LINKED LIST  
### general 
https://leetcode.com/problems/merge-two-sorted-lists/ do it myself 
https://leetcode.com/problems/linked-list-cycle do it myself. use two pointers for linked list. 
https://leetcode.com/problems/remove-nth-node-from-end-of-list

https://leetcode.com/problems/reorder-list
    my try -> fast go to near last element (not last but we need to severe the next pointer). slow will replace next will fast.next -> failed cause too long 
    https://leetcode.com/problems/reorder-list/discuss/801971/Python-O(n)-by-two-pointers-w-Visualization
        solution 1 -> turn into array to make manipulation much easier. go spiral just like the image 
        solution 2 -> split into mid, match first half with reversed second half -> cool technique to get mid point



############### TWO POINTERS 
### 2 pointers 
https://leetcode.com/problems/container-with-most-water/
https://leetcode.com/problems/remove-nth-node-from-end-of-list/
    # thought process
    # fast reaches the end
    # slow reaches size-n
#### sliding window
https://leetcode.com/problems/find-all-anagrams-in-a-string/
https://leetcode.com/problems/minimum-window-substring/ hard
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
    left buy pointer, right sell pointer
https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1074783/Python-Interview-Thought-Process%3A-O(2n)-greater-O(n)
    how to do -> base case get max window. If no duplicate, increase MAX. If duplicate, remove from FIFO until duplicate is out.






############### DICTIONARY or HASHMAP
aa

############### MATH 
https://leetcode.com/problems/basic-calculator
    # https://leetcode.com/problems/basic-calculator/discuss/546092/Simple-Python-Solution-using-stack-with-explanation-inline
    # Simple Example: 2 - 3
    # Initially res will have 2,i.e. res = 2
    # then store '-' in sign. it will be used when 3 comes. ie. sign = -1
    # Now 3 comes => res = res + num*sign
    # for (, move to stack
    # for ), 2-(3+4), Here res=3, num=4, sign=1 stack [2, -]     
https://leetcode.com/problems/2-keys-keyboard/solution/
    code -> all prime numbers input is same output. if can be divided by 'd' do it, increase 'd', until reaches prime number
    how to do -> basically (CPP)(CPPPPP) it's prime 3*5
https://leetcode.com/problems/string-to-integer-atoi/solution/ redo
    approach 1 ->
    approach 2 -> 
    Deterministic Finite Automaton -> 
    TOC (Theory Of Computation) -> state machines either transition to new stay or stay the same. 



############### BINARY SEARCH 
a











############### DYNAMIC PROGRAMMING GUIDE 
### dynamic programming guide
use DP whenever you have to make 'choices'
top-down with memoization : recursion 
bottom-up with tabluation 
If all subproblems must be solved at least once, bottom-up better



patterns 
    greedy
        greedy is a specific kind of DP, and DP is a general greedy.
    0/1 knapsack 
    unbounded knapsack 
    fib
    palindromic subsequence
    longest common substring 
    Minimum (Maximum) Path to Reach a Target
        min to reach a target -> Coin Change
    Distinct Ways : distinct ways to reach target -> Unique Path 
    Merging Intervals : given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.
    DP on Strings :  given two strings s1 and s2, return some result
    Decision Making/ State Machine : Buy Sell Stock






### dynamic programming guide 
#https://www.youtube.com/watch?v=r4-cftqTcdI&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=25
SRTBOT sub-problems, relations, topological order, base case, original problem, and time. // check blackboard on video 
DP = recursion + memo
memoization : remember and reuse 
DAG shortest path 30:00
// stop 31 

#freecodecamp
algorithm whiteboard is hard, translating it into code is the hard part
students have habit of picture something in their mind
base cases donâ€™t branch anymore
try to find familiar in new problem
fib
    time O(2^n)
    dp time O(2n)
gridTraveller memoization
    // stop 41

#https://www.youtube.com/watch?v=mBNrRy2_hVs&s
longest common subsequence





############### DYNAMIC PROGRAMMING CODE 
### general
https://leetcode.com/problems/maximum-subarray/ do it myself 
https://leetcode.com/problems/pascals-triangle/ do it myself


### greedy
a
### 0-1 knapsack either pick or don't pick
https://leetcode.com/problems/maximum-profit-in-job-scheduling/ binary search with dynamic programming knapsack bounded. 
    # https://leetcode.com/problems/maximum-profit-in-job-scheduling/discuss/996255/Python-using-DP-%2B-Binary-Search-(not-using-bisect-built-in)
    # 2 problems 0-1 knapsack and non overlapping 
    # sorted by endTime
    # binary search with (dpEndTime, start) as (right, target), find nonoverlapping time
    # dp -> if it's bigger profit, add endTime and add profit 

### 0/1 bounded knapsack items can't be repeated
https://leetcode.com/problems/partition-equal-subset-sum/
    https://www.youtube.com/watch?v=IsvocB5BJhw 6:00 very good O(n) analyze, last minute also have optimization

### unbounded knapsack
guide 




### minimum/ maximum path to reach a target
https://leetcode.com/problems/coin-change do it myself, unbounded knapsack
https://leetcode.com/problems/minimum-path-sum/ do it myself 
    update matrix in-place with previous 
    https://leetcode.com/problems/minimum-path-sum/discuss/825410/Python3-Dynamic-Programming-90-w-Explaination small things but can improve big O
https://leetcode.com/problems/minimum-falling-path-sum/ do it myself
https://leetcode.com/problems/minimum-cost-for-tickets do it myself, unbounded knapsack  
    how to do -> each 'days', we buy 1-day 7-day and 30-day. Some days maybe not optimized but we only need last day.
    took me 4 hours -> 2 algorithm wrong, 358 wrong, and 'continue' wrong
    approach 1 -> recursion bottom-up go over everything 
    approach 2 -> ...
    https://leetcode.com/submissions/detail/727138197/ best overall, current = current-1 7 30 or 0
https://leetcode.com/problems/perfect-squares
    my try -> 225 / 588 because i used brute force even with memo
    https://leetcode.com/problems/perfect-squares/discuss/275311/Python-DP-and-BFS
    solution 1 -> Build up tabulation using min. relation is dp[i-j*j] so not [i-1] or [i-2]
    solution 2 -> BFS. layer. 
https://leetcode.com/problems/triangle/ do it myself in 40 minutes 
    how to do -> normal Minimum Failing Path but with Triangle 
    my try -> i tried 'directions' technique but it was messy



### distinct ways 
guide 
    2 pointers moving forward
https://leetcode.com/problems/unique-paths do it myself
https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/discuss/355894/Python-DP-with-memoization-explained


### merging intervals 
guide
    keep removing min/ max of intervals
https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/1510611/Greedy-Approach-oror-97-faster-oror-Well-Explained 
    # how to do : non-leaf is product of biggest leaves, sum is all non-leaf, find min sum -> just greedy 
    # code -> with min leaf node, we calculate non-leaf and add it to sum, then remove min.

https://leetcode.com/problems/unique-binary-search-trees/discuss/31761/Python-with-explanation.-I-guess-you-could-call-this-%22DP%22...
    # how to do -> go from 1->n with 'i' as middle. loop 'middle' and all combinations of left * combinations of right
    # my try -> i figure out some solutions, but i pass whole left array rather than left index. I did not figure out the relation 


### decision making (State Machine, a type of 0/1 knapsack)
guide
    draw state machine 
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/803206/PythonJSGoC%2B%2B-O(n)-by-DP-w-Visualization redo, knapsack 0/1, decision making
    # cur_hold : we bought and waiting to sell 
    # everytime we buy something it's negative 
    # either we buy it previously, or we buy current price
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking) 
    # s1 : did buy, can sell
    # best example of State Machine
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/
    # what to do if better prices 10 later
    # -> basically the more buy/ sell the better
    # -> remeber we don't sell yet, we only testing which one better
    # -> most importantly, we buy 1 sell at 9, immediately buy that 9 again and it's not that good
        
### dp on strings I palindromic subsequence 
guide
    expand from small precomputed to bigger. use left, right pointers and know the differences of odd and even
https://leetcode.com/problems/palindromic-substrings do it myself 128/130 cases 
    use precomputed palindrom to compute larger palindrom 
    https://leetcode.com/problems/palindromic-substrings/discuss/392119/Solution-in-Python-3-(beats-~94)-(six-lines)-(With-Detaiiled-Explanation)
        # expand around center. 
        # (b - a - 1) is length of palindrome
        # length of palindrome has a pattern to predict how many palindrom with the same center inside (L+1)//2
        # (b-a)//2 is total palindrome  
        # for a,b in [(i,i),(i,i+1)] palindrom can be center in middle (odd) and center with 2 medians (even)
https://leetcode.com/problems/longest-palindromic-substring/ redo 



### dp on strings II longest common subsequence
guide
    2 pointers for 2 strings, then branch.
    or use tabulation. Only move bottom, right, or bottom right diagonally 
https://leetcode.com/problems/is-subsequence/
https://leetcode.com/problems/longest-common-subsequence/discuss/598508/Python-DP-solution-with-Explanation-%2B-Thinking-process-%2B-Diagram
    DP on strings by move forward 2 pointers
    0/1 knapsack 



############## prefix sum 
guide
    prefix sum : is the sum of all previous index



############### MATRIX
### guide 
rotate change first column to first row, and so on -> list( zip(*matrix) )
rotate rotate y-axis -> matrix[::-1]
rotate counter clock-wise -> (list(zip(*matrix)))[::-1]
https://leetcode.com/problems/spiral-matrix/

### BFS 
https://leetcode.com/problems/number-of-islands/ do it myself  
https://leetcode.com/problems/rotting-oranges do it myself 





############### Graph

### guide 
https://leetcode.com/discuss/study-guide/1326900/graph-algorithms-problems-to-practice
    complete path : there are direct edges betwee any pairs of vertices  
    connected graph : can get from every vertices to another vertices through a series of edges (path)
    weighted graph : edges with number (weight)
    Dijkstra's algorithm : finding the shortest paths between nodes in a graph
    union-find : disjoint-set or merge-find set. store non-overlapping sets -> help find numbers of connected components
    minimum spanning tree : check ###
    topological sort : linear ordering from vertext u to v, and u comes first
    Bellman Ford : for weighted graph, calculate shortest path from a single source vertext to all others
    Floyd Warshall : for directed weighted graph, finding shortest paths with positive of negative edge weights 
    Eulearian Path : finds a path that uses every edge in a graph only once.
  


    
 

dfs patterns
    possible paths/permutations/ways.., then its dfs+back tracking
    lowest common ancestor 

bfs patterns 
    On the other hand, if the question is like shortest path and the graph is not weighted, use bfs




### general 
https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/
    we have group
    match element of other group to remaining groups
    (2,3) same as (3,2)
    my try -> I don't remember how to buildgraph or traverse adjancency list
https://leetcode.com/problems/find-the-town-judge do it myself 
    my try : find all 'potential judge' and check them later -> take too long to check them later

https://leetcode.com/problems/surrounded-regions/ do it myself in 30m
    how to do : 
        get all border O 
        4-directions that border
        if they are in 4-directions, add it to NONCHANGING set 
        then traverse matrix to change all CHANGING SET 
    speed : get all border O(logn) + bfs O(n) + last loop O(n)
    space : borderZero logn + nonchanging n + visited n O(n)
    SPEED and SPACE : check Discord, because it will grow according O(border) which is O(square(total element))




############### MINIMUM SPANNING TREE
### guide
spanning tree : given undirected, connected graph G. Spanning tree is a subgraph of G, includes all vertices with min possible number of edges 
minimum spanning tree : 
    spanning tree with weights, sum of the weights of edges is as min as possible 
    if n vertices, n-1 edges 
Prim's Algorithm : 
    programiz.com/dsa/prim-algorithm great website 
    greedy algo
    start with smallest edges
    keep adding smallest edges to previous 
Kruskal's Algorithm : 
    greedy algo 
    start with smallest edges 
    get smallest edges, but it doesn't need to connect with previous 
    if new edge forming a cycle, don't 
    speed O(n^2)
    with min heap it's O(nlogn)



############### UNION FIND 
###guide
union find (disjoint set)
union find are useful in graph problem
each union has a representaitive, as tree root
find(4) = root
union(1,2) merge find(1) and find(2)





############### BINARY TREE
### bfs
https://leetcode.com/problems/binary-tree-level-order-traversal do it myself but take 1 hint and 2 hours
    https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/458315/Python-99-speed-100-memory-*Simple-Solution*-with-comments memorize this, how to get all elements of that one level
https://leetcode.com/problems/binary-tree-right-side-view/ do it myself 
    speed O(n) since we have to traverse all nodes 
    space O(logn) because only need to store right-hand  
    https://leetcode.com/problems/binary-tree-right-side-view/discuss/56064/5-9-Lines-Python-48%2B-ms much faster code

### dfs
https://leetcode.com/problems/find-duplicate-subtrees do it myself, with 5 hours and bad big O
    https://leetcode.com/problems/find-duplicate-subtrees/discuss/1571352/Python-solution-explained-in-two-steps-for-beginners serialize postorder, put it in dict, if duplicated in dict then it's result 
    https://leetcode.com/problems/find-duplicate-subtrees/discuss/1178526/Easy-%2B-Clean-%2B-Straightforward-Python-Recursive simple dfs, print 'sub' to understand 
    https://leetcode.com/problems/find-duplicate-subtrees/discuss/106020/Python-easy-understand-solution inorder can create same serialization for symmetric trees

### serialize
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/




############### BINARY SEARCH TREE
### basic 
https://leetcode.com/problems/validate-binary-search-tree do it myself
https://leetcode.com/problems/kth-smallest-element-in-a-bst do it myself
    # approach 1 : use Stack for traversal, and also stop at k -> Speed is O(H+k), H can be balanced tree or skewed tree
    # approach optimized : (do it late) 

############### DICTIONARY
https://leetcode.com/problems/lru-cache/ do it myself
    # 

############### STACK 
###guide
can implemented with list, collections.deque, queue.LifoQueue

### general
https://leetcode.com/problems/valid-parentheses do it myself
### bar
https://leetcode.com/problems/trapping-rain-water hard
    # approach 1 : for each element, left side minus the element's height
        # do it for right side too. and min them.
    # approach 2 : DP version of approach 1,  
    # approach 3 : Stack. add bar to the front, smaller or equal bar doesn't matter, if the latest bar is bigger than first bar. Then add to water.
    # approach 4 : 2 pointers. 
    # approach 5 : https://leetcode.com/problems/trapping-rain-water/discuss/17528/Easy-to-understand-Python-10-line-60ms-O(n)
        # over-fill left max, then drain on right min
https://leetcode.com/problems/largest-rectangle-in-histogram/
    # approach 1 Stack https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/452612/Thinking-Process-for-Stack-Solution
        # why Stack -> because bars are in order
        # because of bar 1, bar 2 is useless because max height is 1  
        # don't understand how he calculates width -> (look at code, not tutorial)
        # iâˆ’stack[âˆ’1]âˆ’1 is newestIndex - top index in the stack (after popping 6)
    # approach 2 DP https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/440433/Python-Detailed-Explanation-for-DP-O(n)-Solution-Beats-99.9-RunTime-100-Memory
        # 
https://leetcode.com/problems/daily-temperatures do it myself 
    my try -> some algo error, use list for stack so it's slow 
    approach 1 -> monotonic stack, same as mine 
    approach 2 -> go backward in 'temperatures'. if it's hottest, update 'hottest', if it's smaller, use 'result' to compute -> it's faster because approach 1 Stack have to go forward, then go backward.

https://leetcode.com/problems/car-fleet
    my try : too many variables, should have zip() and sorted() to simplify 
    https://leetcode.com/problems/car-fleet/discuss/255589/Python-Code-with-Explanations-and-Visualization-Beats-95
        how to do ->
            dist/vel is the key
            dist/vel is to calculate ideal arrival time. If new car has smaller ideal arrival time than Top Stack, meaning it's faster and we ignore it, incrase 'fleet' by 1 
    https://leetcode.com/problems/car-fleet/discuss/1299193/Python-Greedy-pattern-explained
        nice DP explanation for pattern "allocating resources to overlapping events"
        how to do -> 
            similar to above ...





############### HEAP  
https://leetcode.com/problems/merge-k-sorted-lists do it myself using brute force
    # approach 2 : compare between k pointers, which one is smaller go to 'res' linked list 
    # approach 3 : optimized approach 2 with priority queue. optimized the comparison process. 
    # approach 4 : merge lists one by one
    # approach 5 : optimized approach 4, merge by divide and conqueor 
https://leetcode.com/problems/find-median-from-data-stream/discuss/74047/JavaPython-two-heap-solution-O(log-n)-add-O(1)-find
    # first half max heap to the front, second half min heap to the front
    # [] and [6]
    # [-6] and [10]
    # [-2] and [6, 10]

############### BACKTRACKING
### guide 
zero padding : can't be just 1, has to be 0001
backtracking is about exploring all possible outcomes, if the outcome is not desirable we go back

### general 
https://leetcode.com/problems/combination-sum/discuss/16510/Python-dfs-solution.
    very basic backtracking 
    how to do ->  
        backtracking - we need to explore all possibilities since they are no limit, we don't need to find min/max, and we can use 'input' multiple times
        just run it until 'target' is negative, that's wrong, if 'target' == 0 then add to 'result'

https://leetcode.com/problems/subsets/solution/
    approach 1 -> cascading. for every new number. add all new number to all previous list. 
    approach 2 -> backtracking. for expanding length. we add remaining number, backtrack, then add remaining number
    approach 3 -> Lexicographic (Binary Sorted) Subsets

https://leetcode.com/submissions/detail/673764853/
    how to do ->
        similar to /combination-sum/ 
        base case if len(permutation) == len(input) then we are good 
        add all numbers with Set

https://leetcode.com/problems/subsets/ do it myself cascading, 
    https://leetcode.com/problems/subsets-ii/discuss/30305/Simple-python-solution-(DFS) DFS without using Set



############### BITMASK and BIT MANIPULATION 
guide
The integers are first converted into binary and then operations are performed on bit by bit
bitmas 
    & AND 
    | OR 
    ~ NOT one complement 
    ^ XOR 
        if same, then it's 0 (false)
        if different, then it's 1
        if both are integer, XOR will compare each bit
    100 >> n right shift divide by 2**n
    100 << n left shift multiple by 2**n
technique
    n&(n-1) will remove the rightmost

operator overloading : same symbol, different meanings in different classes 
https://leetcode.com/problems/sum-of-two-integers/discuss/84278/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently
    a  


### general 
https://leetcode.com/problems/number-of-1-bits/discuss/1044775/Python-n-and-(n-1)-trick-%2B-even-faster-explained
    solution 1 -> keep removing rightmost until 'n' is zero (number of bit stay the same, only value of bit changed)
    solution 2 -> work with group of 2, then 4, then 8


############### TRIE 
### GUIDE 
trie (prefix tree) is type of tree, often for characters
store 'character' by storing as 'key' or  


### TRIE 
https://leetcode.com/problems/implement-trie-prefix-tree/ solve half of it myself
https://leetcode.com/problems/design-add-and-search-words-data-structure/

