############### PYTHON 
### GENERAL
technique
    how to pass list to a function, but only deepcopy() style 
zip() : pair elements in same position in 2 list
hash() : 
sign = [-1, 1][ss=="+"] -> same as sign = 1 if ss=='+' else -1
@cache : cache the results of functions
generator expression and sum :
nonlocal
@lru_cache(maxsize=None) : cache the result of your function with LRU (if maxsize=None then no more LRU)
s[::-1] : reverse s 
Strings are immutable, variables can point at whatever they want.
hash function : key->hash function->hash
hashing : good hasing function is one-way. we can avoid collisions. hash (or hash value) becomes index for hash table
generator
reduce()
mul()
set : unchangable, but can add and remove items




### regex
https://www.youtube.com/watch?v=K8L6KVGG-7o 6:00
import re 
+ : 1 or more 
(option1|option2)
r'' for raw string 
re.search("[a-zA-Z0-9]+@[a-zA-Z]+\.(com|edu|net)", "andrewvu22@gmail.com")
re.sub("(\d\d)-(\d\d)-(\d\d\d\d)", r"\1\2\3", "21-03-1999")

pattern = re.compile(r'abc')
matches = pattern.finditer(data)
for match in matches : 
    print(match)



### lambda 
why use -> anoymous lambda function to used with higher-order function (like filter or map)



## pass arguments



### error 
unhashable type : immutable objects such as tuples are hashable since they have a single unique value that never changes, list can't 

### MATH
eval()

### COPY
shadow copy and deep copy 
deep copy : change to 2nd do not reflect on original
shadow copy : 
shallow list -> 


### STAR *
star
    unpacks tuple and put them as positional arguments for function
    *args for rest arguments 
    **kwargs passing a lit 

### bisect
bisect : binary search algorithm


### dict
max(lst,key=lst.count) : 
max(word_count.items(), key=operator.itemgetter(1))[0] : get items() key-value, then sort by 'value', and return first one 
