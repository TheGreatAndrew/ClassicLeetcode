############### GUIDE 
format
    what's hard 
    my try 
    why this pattern 
    how to do
    what's cool about this 
Union Find, sparse table, seg tree, Fenwick tree, Vectors, bit manipulation

############### GENERAL
https://leetcode.com/problems/task-scheduler
https://leetcode.com/problems/is-subsequence/discuss/385275/Easiest-python-solution-(beats-98-%2B-explanation)
    # interesting way of traversal 2 lists
Greatest English Letter in Upper and Lower Case do it myself
    how to do -> 
https://leetcode.com/problems/happy-number
    my fail -> inteprete the question wrong 
    approach 1 -> just keep going until the set is repeated 
    approach 2 -> niche. Floyd's Cycle-Finding Algorithm. 
https://leetcode.com/problems/count-asterisks/ do it myself 
    how to do -> 
https://leetcode.com/problems/maximum-units-on-a-truck/
    how to do -> 
        totalBox = elements of list * total boxes
        heap push totalBox O(totalBox * logn) 
        heap pop O(TruckSize * logn)
    https://leetcode.com/problems/maximum-units-on-a-truck/discuss/1272564/Short-and-Easy-Solution-w-Explanation-or-Greedily-Select-Max-UnitsBox-Ratio
        solution 1 ->
            n elements of list 
            sorting O(nlogn)
            boxTypes.sort(key=lambda a:-a[1])
        solution 2 ->
            couting sort 
            time O(n)


https://leetcode.com/problems/verifying-an-alien-dictionary/ facebook  
    how to do -> 
        dict index of the alphabet 
        verify if is sorted -> simply compare 2 adjacent input 

https://leetcode.com/problems/longest-common-prefix/ do it myself 
    how to do -> get common of first, second; use that common for second and third 
    https://leetcode.com/problems/longest-common-prefix/solution/ should revisit in the futuer 
        approach 1 horizontal -> same as mine 
            time O(all letters)
        approach 2 vertical -> 
        approach 3 divide conquer -> 


https://leetcode.com/problems/toeplitz-matrix facebook do it myself
    what's cool -> interesting follow-up 
    how to do -> 
        brute force row+1, col+1 
    https://leetcode.com/problems/toeplitz-matrix/solution/
        approach 1 ->
            memorize r1 - c1 == r2 - c2 is diagnonal 
    https://leetcode.com/problems/toeplitz-matrix/discuss/271388/Java-Solution-for-Follow-Up-1-and-2
        follow up 1 ->
            [1,2,3,4],
            [5,1,2,3],
            [9,5,1,2]
            buffer 1-d array 
            buffer [1,2,3,4] remove last 4, and insert first 5 
        follow up 2 -> 
            just divide to multiple matrix 

https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/ facebook 

https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/ facebook
    https://www.youtube.com/watch?v=FTo1kDyE-h4
        how to do ->
            beautiful solution 
            with Stack of "(", if abudant ")" then remove it 
            later use that Stack to remove abundant "("
        what's cool ->  
            remove character S[i] is not very efficient, instead we S[i] = ""

https://www.educative.io/answers/what-is-a-segment-tree
    (look at the illustrations)

https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t#:~:text=Segment%20tree%20stores%20intervals%2C%20and,queries%20%2D%20similar%20to%20segment%20tree.
    a 

https://favtutor.com/blogs/floyd-warshall-algorithm
    All-pairs shortest path problems is used to determine a matrix A such that A(i,j) is the length of a shortest path from i to j.


https://leetcode.com/problems/remove-duplicate-letters/discuss/1859515/Python-oror-O(n)-Beats-98-oror-Stack-oror-Detailed-Explanation-oror-Simple
    lexicographical ->
        just normal dictionary order, but last occurence exception
    how to do ->
        (lexicographical)
        (monotonic increasing stack, think about the last occurences) 
        store the last occurences 
        keep adding to stack
        if new letter is smaller, and the letter before still occur later -> remove previous letter
        why remove from the right -> "bcab" outputs "bca" because c no recurring

    time ->
        stack will contain max 26 character, so its 26N max, but in terms of time-complexity, it is O(M*N) where M is number of distinct characters.


############### BIG O
https://stackoverflow.com/questions/8929284/what-makes-sets-faster-than-lists 
    set is O(1) because position of an element is determined by hashing set, when you retrieve you hash element again.
    sets aren't faster than lists in general -- membership test is faster for sets, and so is removing an element


############### BUILD DATA STRUCTURE 
https://leetcode.com/problems/min-stack/
    https://leetcode.com/problems/min-stack/discuss/1003721/Easy-Python-or-High-Speed
        how to do -> 
            extra stack 
            [-2, 0, -1, -3]
            min of that stack will be [-2,-2,-2,-3] because get min from [-2,0] needs to return -2 


    https://leetcode.com/problems/min-stack/discuss/49183/Python-one-stack-solution-without-linklist
        how to do -> 
            similar to above extra stack problem
            but used tuple instead





###############STRING 
general
    subsequence -> add or remove letters -> 
    anagram -> same letters, different orders -> 

https://leetcode.com/problems/zigzag-conversion/
    how to do ->
        first row and last row increment by -> 2 * (numRows - 1)
        but those middoe rows we will increment -> increment and also get additional next to each other letter 


https://leetcode.com/problems/reverse-string/
    for loop. reverse(). [::-1] 
https://leetcode.com/problems/group-anagrams do it myself
    how to do -> store all anagram combo in Dictionary  
    '''
    for each string, we store all letters as Key in Dict to group them 
    speed O(n*l) where n is all strings, l is length of each string + O(n) 
    space O(2n) for dict, res
    '''  
    https://leetcode.com/problems/group-anagrams/discuss/664252/Python-3-solution-detailed-explanation-faster-than-97.5 exatly same solution, but faster and cool technique, and look at comment    


###############PALINDROME  
### guide 
s=s[::-1]

###general
https://leetcode.com/problems/valid-palindrome-ii/ facebok, do it myself 
    how to do -> if 2 characters doesn't match, the we either remove the 1st or 2nd, and just check the rest 
    https://leetcode.com/problems/valid-palindrome-ii/discuss/632647/Python-Readable-and-Intuitive-Solution-(Generalizable-to-n-deletes)
        how to do -> same idea but better 

https://leetcode.com/problems/valid-palindrome/
    how to do -> isalnum, or two pointers 
    https://leetcode.com/problems/valid-palindrome/discuss/350929/Solution-in-Python-3-(beats-~100)-(two-lines)-(-O(1)-solution-as-well-)
        solution 2 -> two pointers ...


###############ARRAY 
https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/ do it myself 
    how to do -> 
        dict to store last occurences 
        speed O(n) 
        space O(unique)



###############REGEX 
###guide 
aa
###general 
b

############### INTERVAL 
### interval guide 
    there are 6 possible places an interval can be 
    if we sort it, there will only be 3 if else 
        if the second is totally bigger -> first[1] <= second[0]
        of there are overlap, when we do just pick smaller ending -> first[1] < second[1]



https://leetcode.com/problems/non-overlapping-intervals do it myself, pretty new pattern and come up with a guide 45 minutes totoal 
    how to do ->
        sort it, and 3 if else 

https://leetcode.com/problems/insert-interval/
    https://leetcode.com/problems/insert-interval/discuss/21809/Python-O(n)-and-O(nlgn)-solutions
        what's cool -> 
        how to do -> 
            if newInterval before current 
            if newInterval after current -> update new interval to current one (normally we add current to 'res', but now new will be added to 'res', current for later)
            else overlap -> create even Newer Interval 

https://leetcode.com/problems/merge-intervals/
    how to do ->
        3 if and if there are overlap, merge them by min() max() 
        big O 
            https://discord.com/channels/267624335836053506/650401909852864553/999002411798634537
            time : O(nlogn) + O(n**2)
            space : O(n) because Tim Sort 

    approach 1 -> generate a graph ... 
        time O(n^2)
        space O(n^2)
    approach 2 -> sorting with a 'merged' list 





############### ARRAY
### ARRAY GUIDE
patterns : prefix sum, subset backtracking (permutation), sliding window 
### subset backtracking 
https://leetcode.com/problems/letter-combinations-of-a-phone-number/discuss/780232/Backtracking-Python-problems%2B-solutions-interview-prep list



### general

https://leetcode.com/problems/longest-consecutive-sequence do it myself in 30 minutes 
    how to do -> have a Set. keep removing number+1 number-1
    https://leetcode.com/problems/longest-consecutive-sequence/solution/
        approach 3 -> same as my method, just start at 0 and work up
        what's cool -> can loop Set
https://leetcode.com/problems/product-of-array-except-self/ do it myself with 2 hints 
    how to do -> similar to 2 pointers 
    https://leetcode.com/problems/product-of-array-except-self/discuss/65848/Concise-Python-solution-constant-space-(left-to-right-then-right-to-left). 
        how to do -> same idea but no need for extra array
https://leetcode.com/problems/two-sum-ii-input-array-is-sorted do it myself but took me a lot of time to improve 
    how to do -> binary search 
    https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/discuss/51249/Python-different-solutions-(two-pointer-dictionary-binary-search).
        look at comment for big O 
        solution 1 -> 2 pointers to find the sum 
        solution 2 -> simple dict 
        solution 3 -> binary search to find the other 
https://leetcode.com/problems/generate-parentheses/solution/
    what's cool -> learn how to keep track of parentheses
    approach 1 -> keep add ( or ) to explore all possibilities, base case check if it's valid to add to 'res'
        speed -> 
    approach 2 -> backtracking. add all ( 
        speed -> need to read 
    approach 3 -> look in comment for explanation
https://leetcode.com/problems/intersection-of-two-arrays-ii/ do it myself 



### sum
https://leetcode.com/problems/3sum/discuss/725950/Python-5-Easy-Steps-Beats-97.4-Annotated
    what's cool -> they have to turn list to tuple for hashable 
    almost do it myself, i have correct concept


##############ENCODING, SERIALIZATION 
https://www.lintcode.com/problem/659/description 
    explain -> turn list into string, and string can be sent over network much easier, then decode 




##############LINKED LIST  
### general 
https://leetcode.com/problems/merge-two-sorted-lists/ do it myself 
    how to do -> keep comparing 
https://leetcode.com/problems/linked-list-cycle do it myself
    how to do -> use fast and slow pointers 

https://leetcode.com/problems/remove-nth-node-from-end-of-list

https://leetcode.com/problems/reorder-list
    my try -> fast go to near last element (not last but we need to severe the next pointer). slow will replace next will fast.next -> failed cause too long 
    https://leetcode.com/problems/reorder-list/discuss/801971/Python-O(n)-by-two-pointers-w-Visualization
        solution 1 -> turn into array to make manipulation much easier. go spiral just like the image 
        solution 2 -> split into mid, match first half with reversed second half -> cool technique to get mid point
https://leetcode.com/problems/add-two-numbers/
    my try 1160/1568 
    what's cool : many edge cases. 
    https://leetcode.com/problems/add-two-numbers/discuss/1835217/Python3-DUMMY-CARRY-(-**-)-Explained 
        same concept but better soilution
        how to do : keep adding value as traversing, and have 'carry'

https://leetcode.com/problems/copy-list-with-random-pointer do it myself, in 45m while optimized it 
    how to do ->
        first traverse to create second list, and dictionary_connect_a_and_b
        use that dictionary for 'random'







###############TWO POINTERS 
### 2 pointers 
https://leetcode.com/problems/container-with-most-water/ do it myself 
    how to do -> two pointers start, end. We are greedily getting max so the Bar smaller will be removed
    my try -> hard to deal with edge case where same bar length -> actually that edge case doesn't matter cause we will always use Lesser Height Bar to calculate
    what's interesting -> Water 
    time -> O(n) to walk all of them
    space -> O(1) no data 

https://leetcode.com/problems/remove-nth-node-from-end-of-list/ do it myself 
    how to do -> fast reaches the ene, slow reaches size-n
    how to do -> fast go n, then fast slow go together 

https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list do it myself 
    how to do -> even, odd cases

    
#### sliding window
https://leetcode.com/problems/find-all-anagrams-in-a-string/
https://leetcode.com/problems/minimum-window-substring/ hard
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
    explain -> we only need to buy once, and sell once 
    how to do -> discuss/884314 is the standard state machine 
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/1735550/Python-Javascript-Easy-solution-with-very-clear-Explanation
        how to do -> 2 pointers. left sell, right buy. if sell > buy, then we move left 
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39049/Easy-O(n)-Python-solution
        how to do -> min_price is the lowest possible buying price in the array BEFORE price
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/884314/Python-3-greater-Very-simple-solution.-Explanation-added 
        how to do -> a little like state machine 
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/273395/Python-Greedy
        how to do -> a little like state machine too
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/1144842/Several-solutions-in-Python
        kadane's algorithm


https://leetcode.com/problems/longest-substring-without-repeating-characters/ do it myself
    how to do -> first get window, then keep moving/ expanding window 
    speed -> get all char O(n), worst case we have to pop n-1 character. And we only pop it once so it's O(2n)
    space -> worst case set is O(n)
    what's cool -> i don't need 'queue', instead i use 'firstIdx'
    https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1074783/Python-Interview-Thought-Process%3A-O(2n)-greater-O(n)
        how to do -> same idea, but better. base case get window. use queue to keep popping until same. 

https://leetcode.com/problems/permutation-in-string do it myself 
    my try -> did not regconize this is 'sliding window' so have a lot of troubles with edge case 
    speed -> first dictionary is O(s1), second dictionary is O(s2), and we have to keep compare dicitonary and ...
    space -> 2 dictionary so O(s1+s2)
    https://leetcode.com/problems/permutation-in-string/solution/
        approach 4 -> 
            what's cool -> store occurences in array s1map[s1.charAt(i) - 'a']++;
            how to do -> instead of using dictionary, we store occurences in array. 2 loop, for each word, we loop s1 length 
        approach 5 -> sliding window ...
        approach 6 -> optimized sliding window ... 


            




############### DICTIONARY or HASHMAP
aa

############### MATH 
https://leetcode.com/problems/basic-calculator
    # https://leetcode.com/problems/basic-calculator/discuss/546092/Simple-Python-Solution-using-stack-with-explanation-inline
    # Simple Example: 2 - 3
    # Initially res will have 2,i.e. res = 2
    # then store '-' in sign. it will be used when 3 comes. ie. sign = -1
    # Now 3 comes => res = res + num*sign
    # for (, move to stack
    # for ), 2-(3+4), Here res=3, num=4, sign=1 stack [2, -]     
https://leetcode.com/problems/2-keys-keyboard/solution/
    code -> all prime numbers input is same output. if can be divided by 'd' do it, increase 'd', until reaches prime number
    how to do -> basically (CPP)(CPPPPP) it's prime 3*5
https://leetcode.com/problems/string-to-integer-atoi/solution/ redo
    approach 1 ->
    approach 2 -> 
    Deterministic Finite Automaton -> 
    TOC (Theory Of Computation) -> state machines either transition to new stay or stay the same. 


###############BINARY SEARCH 
### knowledge 
bisect_left vs bisect_right is difference if there already exist identical value -> 
bisect.bisect_left([1,2,3], 2) -> return 1
bisect.bisect_right([1,2,3], 2) -> return 2
insort_left -> it runs bisect_left O(logn), then insert O(n) -> overall its O(n)
from sortedcontainers import SortedList -> SortedList is maybe a tree, that's why insert it's O(logn)


### general 
https://leetcode.com/problems/my-calendar-i/ do it myself 
    https://leetcode.com/problems/my-calendar-i/solution
        search O(logn) + sorted insert O(logn0)
        is faster than insort_left O(n)
        with (10,20) and (15,20) -> (15,20) will be behind, and if [idx-1][1] > start then it's false  
        if it's the first or the last in the list, we just add it 




https://leetcode.com/problems/binary-search/ do it myself
https://leetcode.com/problems/search-a-2d-matrix/ do it myself 1 hours with failed submissions 
    how to do -> binary search which row, and later binary search which column of that row 
    https://leetcode.com/problems/search-a-2d-matrix/discuss/26201/A-Python-binary-search-solution-O(logn)
        how to do -> 
    https://leetcode.com/problems/search-a-2d-matrix/discuss/1175274/Find-what's-difficult-in-a-problem-and-think-how-to-get-rid-of-it
        how to do -> 
https://leetcode.com/problems/koko-eating-bananas/
    my try -> I come up with brute force and a little binary search, but too scared to implement it
    why this pattern -> cause left too smal, right too big but can be right 
    https://leetcode.com/problems/koko-eating-bananas/solution/
        appproach 1 : brute force so it's not expected to pass all test cases. basically trying all options of 'k'
        appproach 2 : 
            how to do -> binary search with speed, base case left = right we stop and return
            what's cool -> they don't need to sort the array, they only need left, right, hours_spent 
            speed -> O(n) for traverse whole array each seach. O(logm) with m as maximum number of banana in a pile, so we have to binary search 1 to m -> total O(n*log(m))
            space -> O(1)

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array
    what's cool ->
        maybe don't think of examples, think abstract increase->decrease->increase
    https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solution/
        approach 1 -> binary search. only compare 'mid' and '0'
https://leetcode.com/problems/median-of-two-sorted-arrays/
    what's hard -> i gave up when i see 'Hard' 
    https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/798913/Python-Simple-Two-Pointer-Solution-Time%3A-O(n%2Bm)-Space%3A-O(1)
        what's cool -> Hard problem but easy approach  
        how to do -> two pointers. combine lengths of both lists to LEN. traverse, get list1 if list1 item is smaller, get until we reach LEN//2 
    https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2511/Intuitive-Python-O(log-(m%2Bn))-solution-by-kth-smallest-in-the-two-sorted-arrays-252ms
        how to do ->

https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array do it myself but unconfident at fist because want to optimize
    how to do ->
        2 binary search 
    https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/discuss/717306/Python3-solution-with-detailed-explanation
        how to do -> 
            2 binary search 
    https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/discuss/1054742/Python-O(logn)
        how to do ->
            a


##############PREFIX SUM 
guide
    prefix sum : is the sum of all previous index

general 
    https://leetcode.com/problems/subarray-sum-equals-k/discuss/341399/Python-clear-explanation-with-code-and-example
        how to do ->
            (prefix sum and dictionary)
            [1,2,1,3] 3 


############### MATRIX
### guide 
rotate zip() -> list(zip(*matrix))
rotate reverse -> matrix[::-1]
rotate counter clock-wise -> (list(zip(*matrix)))[::-1]
https://leetcode.com/problems/spiral-matrix/


### general
https://leetcode.com/problems/rotate-image/
    approach 1 -> move forward 4 corners. from 4 corners move inward.
    approach 2 -> transpose than reverse left-to-right 
        transpose -> the right-side of diagnoal
        left-to-right -> switch first-half through n//2 
    https://leetcode.com/problems/rotate-image/discuss/18884/Seven-Short-Solutions-(1-to-7-lines)
        solution 1 -> why A[:]


https://leetcode.com/problems/valid-sudoku/ do it myself in 30 minutes
    how to do -> brute force check 3 different things
    what's cool -> i douby myself and don't even think my brute force will work 
    https://leetcode.com/problems/valid-sudoku/discuss/729180/Python-solutions-or-Single-Traversal-or-Single-Dictionary
        how to do -> add position of all occurences of a number. Then check if (same row) or (same column) or (same box)
        what's cool -> do 3 checks with single traversal 
    https://leetcode.com/problems/valid-sudoku/discuss/511365/Simple-Intuitive-Python-Approach
        how to do -> array of set, 'k subbox' with 9 areas 
        what's cool -> array of set 

### BFS 
https://leetcode.com/problems/number-of-islands/ do it myself  
https://leetcode.com/problems/rotting-oranges do it myself 





############### Graph

### guide 
https://leetcode.com/discuss/study-guide/1326900/graph-algorithms-problems-to-practice
    complete path : there are direct edges betwee any pairs of vertices  
    connected graph : can get from every vertices to another vertices through a series of edges (path)
    weighted graph : edges with number (weight)
    union-find : check ### -> help find numbers of connected components
    Floyd Warshall : for directed weighted graph, finding shortest paths with positive of negative edge weights 
    Eulearian Path : finds a path that uses every edge in a graph only once.
    maximum network flows 
    biparte matching 




dfs patterns
    possible paths/permutations/ways.., then its dfs+back tracking
    lowest common ancestor 

bfs patterns 
    On the other hand, if the question is like shortest path and the graph is not weighted, use bfs




### general 
https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/
    we have group
    match element of other group to remaining groups
    (2,3) same as (3,2)
    my try -> I don't remember how to buildgraph or traverse adjancency list
https://leetcode.com/problems/find-the-town-judge do it myself 
    my try : find all 'potential judge' and check them later -> take too long to check them later

https://leetcode.com/problems/surrounded-regions/ do it myself in 30m
    how to do : 
        get all border O 
        4-directions that border
        if they are in 4-directions, add it to NONCHANGING set 
        then traverse matrix to change all CHANGING SET 
    speed : get all border O(logn) + bfs O(n) + last loop O(n)
    space : borderZero logn + nonchanging n + visited n O(n)
    SPEED and SPACE : check Discord, because it will grow according O(border) which is O(square(total element))

https://leetcode.com/problems/redundant-connection/ do it myself in 30m
    how to do : 
        run intially to collect all nodes 
        keep remove edges, and see if we can still reach all 
        (keep removing the last edges, if we can reach all, than return True immediately)  
    speed : initial loop O(edges) and for each edges, run entire edges again O(edges*edges)
    space : 
    approach 1 -> look at comment. Doing Cycle Prevention, build a graph one edge at at time, if there already a path, then the new edge will create cycle 
    approach 2 -> 
    https://leetcode.com/problems/redundant-connection/discuss/1295728/JS-Python-Java-C%2B%2B-or-Simple-Union-Find-Solution-w-Explanation
    solution 1 -> look at comment from my submission

https://leetcode.com/problems/clone-graph/
    how to do : 
        dictionary to make sure you store correct cloned node, and can be reuse -> very creative 
https://leetcode.com/problems/pacific-atlantic-water-flow/
    my try -> i only go 2-directions so it's wrong, i did not understand questions correctly, i also only traverse matrix normally 
    https://leetcode.com/problems/pacific-atlantic-water-flow/discuss/543988/Easy-understand-DFS-solution-beat-97
        how to do ->
            loop 4 borders, dfs, if newR newC is bigger than current then we keep dfs
        lesson -> with dfs, we don't need to worry about which row, column comes first 
        

https://leetcode.com/problems/word-search/ nearly do it myself. interview others. 
    space : O(s )
    time : O(N⋅3^L) with N = mxn 



#dfs 
# https://structy.net/problems/depth-first-values why '*', basic dfs
# https://structy.net/problems/max-root-to-leaf-path-sum sum of path is root.val
# https://leetcode.com/problems/diameter-of-binary-tree/ do 2 tasks inside recursion
# https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree interesting recursion 
# https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ medium but actually hard. redo


#bfs
# https://structy.net/problems/breadth-first-values basic bfs
# https://leetcode.com/problems/invert-binary-tree/ bfs 
# https://leetcode.com/problems/balanced-binary-tree/ recursion
# https://leetcode.com/problems/invert-binary-tree/submissions/ my two submission has different speed






############### UNION FIND 
###guide
https://www.youtube.com/watch?v=ayW5B2W9hfo
    union find (disjoint set)
    union find are useful in graph problem
    each union has a representaitive, as tree root
    find(4) = root
    union(1,2) merge find(1) and find(2)
https://www.youtube.com/watch?v=wU6udHRIkcc
    weight and rank is better 
    disjoint set : sets that dont connect
    detecting cycles ->
        set have (1,2,3), for (1,3) edge, 1 and 3 already in set, so don't include this edge or we will have cycle
        if different set, perform Union()
    graph representation -> Union() keep adding set
    array representation -> 
        value -2 is parent 
        value n will have n as parent 
        value more negative is a bigger parent 
    collapsing find
        make all nodes link with the root parent 







###############BINARY TREE
### guide
    strategy
        really good at recursion
        depth, height -> Steve's question 
        level order traversal -> BFS with for-loop 
        lowest common ancestor -> 3 flags. DFS to build path for each node, then popping. Or DFS to build parent.
        finding a path between 2 nodes -> also lowest common ancestor step-by-step-directions-from-a-binary-tree-node-to-another
        serialize -> 

### general
https://leetcode.com/problems/path-sum/ do it myself å
    edge case [1,2] 1 will be wrong because it will go null right 


https://leetcode.com/problems/delete-nodes-and-return-forest/discuss/345009/Python-BFS-Solution
    how to do ->
        'hasParent' for when to create another linked list
https://leetcode.com/problems/invert-binary-tree/ do it myself 
    what's cool -> passing node reference 
https://leetcode.com/problems/maximum-depth-of-binary-tree do it myself 
https://leetcode.com/problems/maximum-depth-of-n-ary-tree/ do it myself 
https://leetcode.com/problems/diameter-of-binary-tree/ do it myself 
    how to -> keep track of local sum and local max
https://leetcode.com/problems/balanced-binary-tree/
    what's cool -> 
        for depth you want push an incrementing counter down the tree
        for height you want to increment the return value of nodes (and a max over nodes)
    https://leetcode.com/submissions/detail/709809165/
        what's cool ->
            if left == -1 or right == -1 or abs(left -right) > 1 :  to check everything at the same time 
        how to -> 
            1 + max(left, right) at every node 
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ do it myself
    how to do -> 
        dfs to collect
        start[0] = same and start[0+1] same
        path[0] = same and start[0+1] same 
        can pop  
    time : DFS O(n), copy path O(2n), popping O(n)
    space : 
    https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/
        approach 1 -> 
            the node with 3 flags (left, root, right) as true, is the answer 
        approach 2 -> 
            build parent, while get the start and end node (parent using dictionary)
            traverse up, the first common ancestor is the ancestor 
        approach 3 -> 
            #
https://leetcode.com/problems/subtree-of-another-tree/ do it myself 
    what's cool -> 
        do the encoding/ decoding tree 
    https://leetcode.com/problems/subtree-of-another-tree/discuss/386209/Python-98-speed-with-comments 
        beautiful encoding tree 
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ do it myself 
    what's cool -> 
        so hard to append list with 2 recursions 
        def build(node, target, path) : 
            if node is None : return     
            path.append(node.val)
            if node.val == target.val : 
                return node.val
            elif node.val > target.val : 
                return build(node.left, target, path) 
            else : 
                return build(node.right, target, path)           
            return node.val 
    https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/discuss/519429/Python-O(n)-sol-by-DFS.-w-Hint-and-Explanation
        how to do ->
            more neat 
            if p and q are on different side of the current node, then current node is LCA

https://leetcode.com/problems/count-good-nodes-in-binary-tree/ 
    how to do ->
        X bigger than all ancestors, not just direct parent 
    speed O(n)
    space O(1)

https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ do it myself 
    how to do ->
        build a string with join('')
        build a tree by looping array 

https://leetcode.com/problems/binary-tree-level-order-traversal do it myself 
    how to do ->
        BFS with for-loop
https://leetcode.com/problems/binary-tree-right-side-view/ do it myself 
    speed O(n) since we have to traverse all nodes 
    space O(logn) because only need to store right-hand  
    https://leetcode.com/problems/binary-tree-right-side-view/discuss/56064/5-9-Lines-Python-48%2B-ms much faster code

https://leetcode.com/problems/find-duplicate-subtrees do it myself, with 5 hours and bad big O
    https://leetcode.com/problems/find-duplicate-subtrees/discuss/1571352/Python-solution-explained-in-two-steps-for-beginners serialize postorder, put it in dict, if duplicated in dict then it's result 
    https://leetcode.com/problems/find-duplicate-subtrees/discuss/1178526/Easy-%2B-Clean-%2B-Straightforward-Python-Recursive simple dfs, print 'sub' to understand 
    https://leetcode.com/problems/find-duplicate-subtrees/discuss/106020/Python-easy-understand-solution inorder can create same serialization for symmetric trees

https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/ lowest common ancestor 
    what's cool ->
        subproblem -> tree from node A to node B
        subproblem -> 

    https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/discuss/2005805/Python3-DFS-easy-solution-using-deque
        how to do ->
            (path to start, path to end, then lowest common ancestor)
    https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/discuss/1612071/Accepted-Python-Super-Simple-or-DFS-%2B-BFS
        how to do ->
            (simple DFS to collect start and end, also add 'parent' attribute to ListNode)
            (then BFS)


###############BINARY SEARCH TREE
### basic 
https://leetcode.com/problems/validate-binary-search-tree do it myself

https://leetcode.com/problems/kth-smallest-element-in-a-bst do it myself
    how to do ->
        approach 1 : use Stack for traversal, and also stop at k -> Speed is O(H+k), H can be balanced tree or skewed tree
        approach optimized : (do it late) 
    how to do -> 
        speed O(logn) : run height of a tree
            time complexity of these operations is O(H), where H is a height of the binary tree. H = logN for the balanced tree and H = N for a skewed tree.
        space O(1)
    how to do ->
        left-root-right 
        local var TIME, if TIME = k return that node
        worst case O(n) or O(k) k=n 
        space O(1)


###############DIVIDE AND CONQUER
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
    how to do ->
        very easy solution, i need to practice more of this 



###############NARRAY TREE 
### guide 
a

### general 
https://leetcode.com/problems/n-ary-tree-level-order-traversal/ do it myself 
    how to do ->
        BFS each level





###############DICTIONARY
https://leetcode.com/problems/lru-cache/ do it myself, do it myself dict and queue
    how to do -> OrderedDict which tracks the orders of inserted key
    OrderedDict popitem(last=False) .move_to_end(key)
    https://leetcode.com/problems/lru-cache/discuss/352295/Python3-doubly-linked-list-and-dictionary 
        double linked list

        

###############STACK 
###guide
can implemented with list, collections.deque, queue.LifoQueue

### general
https://leetcode.com/problems/valid-parentheses do it myself
### bar
https://leetcode.com/problems/trapping-rain-water do it myself, second hard problem I solved
    my try : monotonic stack with first bar as max. loop all height. At the end, when first bar is actually max then we do more computation.
        speed : O(n) + O(n)
    approach 1 : brute force for each bar, check with both sides 
        speed O(n^2) cause traverse*traverse
    approach 2 : find max height from left-end view, right-end view. Then use min()
        speed O(n) cause 2 for-loop, then last min for-loop
        space O(n)
    approach 3 : Stack  
        monotonic decreasing bar 
        if newBar is bigger. We have 3 vairables (newBar as bound right, newly popped stack waterArea, and top of the stack as bound left)
        distance * min(bound right, bound left)
        then we add newBar to stack 
        speed -> O(n)
    approach 4 : 2 pointers
        for any Bar, there are always 2 Borders max_left and max_right
        if we are going from left-to-right, then we alwaysk now what is max_left 
        vice versa for right-to-left 
        but we have height[left] < height[right] : left_pointer += 1
        for example -> if last Bar is highest, then max_right is last bar and we will keep moving left_pointer
        speed -> O(n) cause single iteration
    approach 5 : https://leetcode.com/problems/trapping-rain-water/discuss/17528/Easy-to-understand-Python-10-line-60ms-O(n)
        over-fill left max, then drain on right min
    https://leetcode.com/problems/trapping-rain-water/discuss/1005489/Python-Two-pointer-approach-with-explanation-O(n)-time-O(1)-space
        approach 3 but in Python



https://leetcode.com/problems/largest-rectangle-in-histogram/
    # approach 1 Stack https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/452612/Thinking-Process-for-Stack-Solution
        # why Stack -> because bars are in order
        # because of bar 1, bar 2 is useless because max height is 1  
        # don't understand how he calculates width -> (look at code, not tutorial)
        # i−stack[−1]−1 is newestIndex - top index in the stack (after popping 6)
    # approach 2 DP https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/440433/Python-Detailed-Explanation-for-DP-O(n)-Solution-Beats-99.9-RunTime-100-Memory
        # 
        
https://leetcode.com/problems/daily-temperatures do it myself 
    my try -> some algo error, use list for stack so it's slow 
    approach 1 -> monotonic stack, same as mine 
    approach 2 -> go backward in 'temperatures'. if it's hottest, update 'hottest', if it's smaller, use 'result' to compute -> it's faster because approach 1 Stack have to go forward, then go backward.

https://leetcode.com/problems/car-fleet
    my try : too many variables, should have zip() and sorted() to simplify 
    https://leetcode.com/problems/car-fleet/discuss/255589/Python-Code-with-Explanations-and-Visualization-Beats-95
        how to do ->
            dist/vel is the key
            dist/vel is to calculate ideal arrival time. If new car has smaller ideal arrival time than Top Stack, meaning it's faster and we ignore it, incrase 'fleet' by 1 
    https://leetcode.com/problems/car-fleet/discuss/1299193/Python-Greedy-pattern-explained
        nice DP explanation for pattern "allocating resources to overlapping events"
        how to do -> 
            similar to above ...





###############HEAP  
https://leetcode.com/problems/merge-k-sorted-lists do it myself. Only problem is Python 3 weird heap.  
    tuples are compared elementwise, so if there's a tie on the l.val, it then tries to compare the second elements
    do i use existing node or new node -> new node 
    how to do ->
        each node 
        complexity 
            n number of nodes 
            k number of linked lists
            time O(nlogn * 2)-> O(n) for traverse the list, O(logn) for heap push. Then O(logn) for heap pop, O(n) building new linked list 
                correct time O(nlogk) -> push and pop O(logk), k because each time we get min from k elements, not n total elements. O(n) for building final linkedlist
            space O(k) -> k is number of linked lists O(k) for heap and new linked list 
                correct space -> O(n) for new linked list, and O(k) for heap 
    https://leetcode.com/problems/merge-k-sorted-lists/solution/
        approach 1 -> brute force 
        approach 2 -> compare head of nodes
            time : O(kN) so I was right 
            space : O(n) for new linked list 
        approach 3 -> optimize approach 2 by PriorityQueue
        approach 4 -> merge 
        approach 5 -> divide and conqueror. keep merging every pair of linked lists
    https://leetcode.com/problems/merge-k-sorted-lists/discuss/465094/Problems-with-Python3-and-Multiple-Solutions
        how to do ->
            approach 3 but for Python3 
    https://leetcode.com/problems/kth-largest-element-in-an-array/
https://leetcode.com/problems/k-closest-points-to-origin do it myself 
https://leetcode.com/problems/reorganize-string/ do it myself 
    how to do ->
        if 1 letter that is the majority, then it's impossible
        otherwise just build the string from most occurence char, 2nd most occurence char 

https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/ do it myself 
    how to do ->
        counter then minheap 


https://leetcode.com/problems/kth-largest-element-in-a-stream/discuss/482591/Simple-Python-Solution-or-Maintain-Min-Heap-whose-size-is-always-kept-at-k
    my try -> pass 9/10 but time limit exceed 


https://leetcode.com/problems/merge-k-sorted-lists do it myself using brute force
    # approach 2 : compare between k pointers, which one is smaller go to 'res' linked list 
    # approach 3 : optimized approach 2 with priority queue. optimized the comparison process. 
    # approach 4 : merge lists one by one
    # approach 5 : optimized approach 4, merge by divide and conqueor 
https://leetcode.com/problems/find-median-from-data-stream/discuss/74047/JavaPython-two-heap-solution-O(log-n)-add-O(1)-find
    # first half max heap to the front, second half min heap to the front
    # [] and [6]
    # [-6] and [10]
    # [-2] and [6, 10]

https://leetcode.com/problems/top-k-frequent-elements/ do it myself 
    how to do -> dict then heap 
    speed -> pop heap k times O(klogn), read everything into dict O(n)
    https://www.youtube.com/watch?v=YPTqKIgVk-k BUCKET SORT 
        how to do O(klogn) -> use heap
        how to do O(n) ->
            bucket sort // 3:40
    https://leetcode.com/problems/top-k-frequent-elements/discuss/484980/Python-Explained-Two-Simple-Heap-solutions 
        how to do -> if it's over k, then pop min


############### BACKTRACKING
### guide 
zero padding : can't be just 1, has to be 0001
backtracking is about exploring all possible outcomes, if the outcome is not desirable we go back
steps to solve pattern ->
    /subset has great backtracking solution
    choose -> recursive what 
    constraint -> 
    goal -> 
https://www.geeksforgeeks.org/backtracking-introduction/
    back tracking algorithm is not as good as DP or Greedy, but there are cases when backtracking is great 
    can be used for Knapsack problem

### general 
https://leetcode.com/problems/permutations/ do it myself 
    https://leetcode.com/submissions/detail/719236963/ normal recursion 
    https://leetcode.com/problems/permutations/discuss/360280/Python3-backtracking backtracking 

https://leetcode.com/problems/permutations-ii do it myself 

https://leetcode.com/problems/combination-sum/discuss/16510/Python-dfs-solution.
    very basic backtracking 
    how to do ->  
        backtracking - we need to explore all possibilities since they are no limit, we don't need to find min/max, and we can use 'input' multiple times
        just run it until 'target' is negative, that's wrong, if 'target' == 0 then add to 'result'


https://leetcode.com/submissions/detail/673764853/
    how to do ->
        similar to /combination-sum/ 
        base case if len(permutation) == len(input) then we are good 
        add all numbers with Set

https://leetcode.com/problems/subsets/ do it myself cascading
    approach 1 -> cascading. for every new number. add all new number to all previous list.
        time ->
        space ->  
    approach 2 -> backtracking. for expanding length. we add remaining number, backtrack, then add remaining number
        time -> O(N*2^n) I think it's O(Each Element * ...)
        space -> 
    approach 3 -> Lexicographic (Binary Sorted) Subsets
    https://leetcode.com/problems/subsets-ii/discuss/30305/Simple-python-solution-(DFS) DFS without using Set

https://leetcode.com/problems/n-queens/ do it myself. first hard problem.
    how to do ->
        recursive backtrack 
        when place a Queen, mark all 'attacked path' as forbidden. continue doing that 
    https://leetcode.com/problems/n-queens/discuss/19810/Fast-short-and-easy-to-understand-python-solution-11-lines-76ms
        what's cool -> check diagonally 
        how to do ->
            TODO : repeat learn 
            read the comment 
            recursively calculate board, each row have one, check for column/left diagonal/ right diagnoal -> build board later
            we are checking previous diagonally, so check 2 slopes left up -1 and right up +1 
            p + q same as y + x = b, look for b (y-intercept) cause we have m (slope)
            slope m is going up +1 or down -1
            p -> row number 
            q -> column number 
            xy_sum -> 
            xy_dif ->
    https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/ 
        how to do ->
            backtrack
https://leetcode.com/problems/palindrome-partitioning
    how to do -> backtracking with splicing [start:end] and get all possible combination of substrings 
    my try -> i can think of backtracking, even backtracking with DP. But my code is wrong 
    https://leetcode.com/problems/palindrome-partitioning/solution/
        approach 1 -> backtracking and DFS. same concept with mine.
            time complexity -> 
                total O(N*2^N)
                N is length of string
                O(2^N) for worst case keep having palindrome tree
                O(n) to generate each substring 
        approach 2 -> backtracking with Dynamic Programming. instead of isPalindrome(), we use DP() for palindrome 
            end - start <= 2 is ...
    ALL SUBMISSIONS 
        recursive without backtracking -> https://leetcode.com/submissions/detail/736764814/
        recursion with backtracking -> 
        recursion with DP https://leetcode.com/submissions/detail/736785203/ 




##############BIT MANIPULATION
guide
The integers are first converted into binary and then operations are performed on bit by bit
bitmas 
    & AND 
    | OR 
    ~ NOT one complement 
    ^ XOR true only if its different 
        if same, then it's 0 (false)
        if different, then it's 1 (true). If it's 0 ^ 2, it's 2. If it's 0 ^ 3, it's 3. 
        if both are integer, XOR will compare each bit
    100 >> n will be 10 -> right shift divide by 2**n
    100 << n will be 1000 -> left shift multiple by 2**n
operator overloading : same symbol, different meanings in different classes 
https://www.youtube.com/watch?v=NLKQEOgBAnw&t=189s
    negative -> two's complement
        invert bits -> add 1 at the end -> add 1 for signs in the front 
    logical and arithemetic shifting 
        right shift : move evrything right. remove trash. divide by 2, rounding down 
        logical right shift: fill in 0
        arithemetic right shift : no fill in, rounding up 
    mask : same length with input 
    get ith bit ---> ( input&(1<<i) ) !=0
    set ith bit -> ( input|(1<<i) )
    clear ith bit -> ( input& ~(1<<i) ) 
technique
    n&(n-1) will remove the rightmost
    bin(number)[3:]

### general 
https://leetcode.com/problems/subsets/
    how to do 
        1 mean presence 
        zero left padding -> because of how bin() works, we want 001 not just 1, so we use a trick with 1001 and remove the first 1  
        bitmask = bin(i)[3:]
        
https://leetcode.com/problems/single-number/ do it myself
    how to do -> 
        x^0 = x
        x^x = 0 
        x^y^x = (x^x)^y = 0^y = y
        4^3 = 7 because it compares each bit 
        since everything start at 0, we XOR index 0 and value 0, and so on. The one left is missing. 



https://leetcode.com/problems/missing-number/discuss/1585333/Python-THE-Best-explanation-bitwise-and-sum
    https://leetcode.com/problems/missing-number/discuss/1585333/Python-THE-Best-explanation-bitwise-and-sum
        how to do ->
            XOR operations are commutative -> 1^1^2 == (1^1)^2 == (2^1)^1 == 2
            Order does not mater  



https://leetcode.com/problems/reverse-bits/
    https://www.youtube.com/watch?v=UcoN6UjAI64
        comment section algo ->
            (logic similar to reverse normal int, we get last %10, *10, then /10)
            (logic is get last bit, <<, then remove last bit)
              


https://leetcode.com/problems/sum-of-two-integers/discuss/84278/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently
    a  

https://leetcode.com/problems/number-of-1-bits/discuss/1044775/Python-n-and-(n-1)-trick-%2B-even-faster-explained
    solution 1 -> keep removing rightmost until 'n' is zero (number of bit stay the same, only value of bit changed)
    solution 2 -> work with group of 2, then 4, then 8




############### TRIE 
### guide  
trie (prefix tree) is type of tree, often for characters
store 'character' by storing as 'key' or  


### general  
https://leetcode.com/problems/implement-trie-prefix-tree/ solve half of it myself
https://leetcode.com/problems/design-add-and-search-words-data-structure/
https://leetcode.com/problems/replace-words/ do it myself 
    what's cool -> finally learn how to use Trie 
    

https://leetcode.com/problems/search-suggestions-system
    my trie ->
        standard trie 
        for searchPrefix(), i keep going and return all the words 
    https://leetcode.com/problems/search-suggestions-system/discuss/864637/Python-3-or-Two-Methods-(Sort-Trie)-or-Explanation
        how to do ->
            binary search 

        how to do ->
            trie
            sort before anything. TrieNode has words 
    
        how to do ->
            trie but don't go from beginning everytime 
            self.node = self.root







### CONTEST
5218. Sum of Numbers With Units Digit K not done 
https://leetcode.com/discuss/interview-question/1803238/Amazon-or-OA-or-sum-of-cache-optimization-power-for-all-sub-arrays
https://leetcode.com/problems/subtree-of-another-tree/discuss/386209/Python-98-speed-with-comments
https://leetcode.com/problems/most-common-word/solution/
https://leetcode.com/problems/group-anagrams/
https://leetcode.com/problems/valid-anagram/ do it myself
https://leetcode.com/problems/longest-repeating-character-replacement don't understand 



############# SIMULATION 
https://leetcode.com/problems/robot-bounded-in-circle/ SIMULATION, do it myself 
    https://leetcode.com/problems/robot-bounded-in-circle/discuss/850464/Python-3-or-Simulation-or-Explanation
        how to do ->
            direction 0 1 2 3 
            coor 
            2 success case


https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/894031/Python-O(logn)-Detailed-Explanation     
    how to do ->
        split into 2 normal arrays, the others are 2 abnormal arrays 
    
https://leetcode.com/problems/largest-rectangle-in-histogram/
    how to come up with this solution ->
    how to do ->
        monotonic stack increasing 
        if we meet a smaller 'height'
        then we trace back, area = width * height. width is 'index', and height is smallest bar, which is the first one since this is monotonic stack

    https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/28917/AC-Python-clean-solution-using-stack-76ms
        how to do -> same as above 

https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/ 
    what's cool -> sliding window SUM but have negative
    how to do ->
        (monotonic queue)
        don't use 'nums' input directly, use PrefixSum
        think about it, if >= k then we will make it <k for adding new number
        ....


#############MERGE SORT 
### guide
    principals 
        a 
    algo 


https://www.youtube.com/watch?v=4VqmGXwpLqc
    mergesort to divide -> keep dividing and recursion 
    merge to combine -> compare to merge, and then merge the rest 
    worst time -> O(gnlogn)
https://www.programiz.com/dsa/merge-sort kind of similar merge sort 
https://leetcode.com/problems/sort-an-array/ do it myself merge sort. 
 



############### QUICK SELECT
guide 
    principals 
        keep partition into 2 half based on 'last pivot' 
        keep track of 'inflection pivot'
        if 'inflection pivot = target' we are good 

    algo 
        (for kth-largest-element-in-an-array)
        pivot for last, p is the spot between smaller and bigger partition 
        update k because for k = 2, k is 2nd index from behind 


    big O    
        average O(n)
        worst O(n**2)
        n+n/2+n/4 = 2n which is n

    

https://leetcode.com/problems/kth-largest-element-in-an-array do it myself with heap 
    how to do ->
        with heap 
        k is capacity 
        time O(nlogk) -> loop through all elements O(n) and pushpop O(logk)
        space O(k) -> O(k)
    https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/762174/4-python-solutions-with-step-by-step-optimization-plus-time-and-space-analysis
        how to do -> 
    https://www.youtube.com/watch?v=XEmy13g1Qxc
        heap is O(n + klogn) -> if heapify all, then pop k times 
        quick select 
            a 



###############BINARY INDEXED TREE (FENWICK TREE)
### guide
    principals
        
https://www.youtube.com/watch?v=CWDQJGaN1gY explain 
    use -> to get prefix sum 
    flip the rightmost bit 
    femwick by parent index + next - 1 

https://www.youtube.com/watch?v=uSFzHCZ4E-8 
    allow to do range calculation 
    sum(5,10) = sum[10] - sum[4]

https://www.hackerearth.com/practice/notes/binary-indexed-tree-or-fenwick-tree/
    bbb 


### general 
https://leetcode.com/problems/count-of-smaller-numbers-after-self/
    https://www.youtube.com/watch?v=wWrprKyQmE4 
        appproach 1->
            we go from right-to-left. use SortedList and binary search to see how many smaller elements. 
            time -> O(nlogn) cause loop, inside bisect and insert
        appproach 2->
            binary indexed tree -> 
            time -> O(nlogn)

    https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76731/Nlogn-Python-solution-binary-indexed-tree-160-ms





###############Tarjan's Bridge-Finding Algorithm
    when to use 
        Tarjan's strongly connected component algorithm : detect if there are cycles
    principals 
        
    algo 
        a 

https://www.youtube.com/watch?v=wUgWX0nc4NY
    Strongly Connected Component
    bunch of connected component, if leave there is no way to go back 
    low-link value : lowest node reachable by another node (root of union find)
    use a stack to improve 
    6:18 pseudo code 
    if it's in the stack, that's the low-lin value 
    12:00

### general 
https://leetcode.com/problems/critical-connections-in-a-network/discuss/1174196/JS-Python-Java-C%2B%2B-or-Tarjan's-Algorithm-Solution-w-Explanation
    how to do ->
        critical connection = bridge 
        combination of DFS and union find 
        DFS to keep track of earlist node 



https://leetcode.com/problems/find-duplicate-file-in-system/