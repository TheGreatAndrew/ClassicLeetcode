############### GUIDE 
A monotonic stack is a stack whose elements are monotonically increasing or descreasing.
format
    what's hard 
    my try 
    why this pattern 
    how to do
    what's cool about this 
Array, Trie, Union Find, sparse table, seg tree, Fenwick tree, Vectors, bit manipulation

############### GENERAL
https://leetcode.com/problems/task-scheduler
https://leetcode.com/problems/is-subsequence/discuss/385275/Easiest-python-solution-(beats-98-%2B-explanation)
    # interesting way of traversal 2 lists
Greatest English Letter in Upper and Lower Case do it myself
    how to do -> 
https://leetcode.com/problems/happy-number
    my fail -> inteprete the question wrong 
    approach 1 -> just keep going until the set is repeated 
    approach 2 -> niche. Floyd's Cycle-Finding Algorithm. 
https://leetcode.com/problems/count-asterisks/ do it myself 
    how to do -> 



############### BIG O
https://stackoverflow.com/questions/8929284/what-makes-sets-faster-than-lists 
    set is O(1) because position of an element is determined by hashing set, when you retrieve you hash element again.
    sets aren't faster than lists in general -- membership test is faster for sets, and so is removing an element



############### STRING 
general
    subsequence -> add or remove letters -> 
    anagram -> same letters, different orders -> 
    palindrom -> reverse string and it is the same -> 
    permutation, palindrome, superset -> 
    can be 2 pointers, sliding window


https://leetcode.com/problems/reverse-string/
    for loop. reverse(). [::-1] 
https://leetcode.com/problems/group-anagrams do it myself
    how to do -> store all anagram combo in Dictionary  
    '''
    for each string, we store all letters as Key in Dict to group them 
    speed O(n*l) where n is all strings, l is length of each string + O(n) 
    space O(2n) for dict, res
    '''  
    https://leetcode.com/problems/group-anagrams/discuss/664252/Python-3-solution-detailed-explanation-faster-than-97.5 exatly same solution, but faster and cool technique, and look at comment    


############### REGEX 
###guide 
aa
###general 
https://leetcode.com/problems/valid-palindrome/
    how to do -> isalnum, or two pointers 
    https://leetcode.com/problems/valid-palindrome/discuss/350929/Solution-in-Python-3-(beats-~100)-(two-lines)-(-O(1)-solution-as-well-)
        solution 2 -> two pointers ...





############### ARRAY
### ARRAY GUIDE
patterns : prefix sum, subset backtracking (permutation), sliding window 
### subset backtracking 
https://leetcode.com/problems/letter-combinations-of-a-phone-number/discuss/780232/Backtracking-Python-problems%2B-solutions-interview-prep list

### general
https://leetcode.com/problems/insert-interval/
    https://leetcode.com/problems/insert-interval/discuss/21809/Python-O(n)-and-O(nlgn)-solutions
        what's cool -> 
        how to do -> 
            if newInterval before current 
            if newInterval after current -> update new interval to current one (normally we add current to 'res', but now new will be added to 'res', current for later)
            else overlap -> create even Newer Interval 
https://leetcode.com/problems/longest-consecutive-sequence do it myself in 30 minutes 
    how to do -> have a Set. keep removing number+1 number-1
    https://leetcode.com/problems/longest-consecutive-sequence/solution/
        approach 3 -> same as my method, just start at 0 and work up
        what's cool -> can loop Set
https://leetcode.com/problems/product-of-array-except-self/ do it myself with 2 hints 
    how to do -> similar to 2 pointers 
    https://leetcode.com/problems/product-of-array-except-self/discuss/65848/Concise-Python-solution-constant-space-(left-to-right-then-right-to-left). 
        how to do -> same idea but no need for extra array
https://leetcode.com/problems/two-sum-ii-input-array-is-sorted do it myself but took me a lot of time to improve 
    how to do -> binary search 
    https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/discuss/51249/Python-different-solutions-(two-pointer-dictionary-binary-search).
        look at comment for big O 
        solution 1 -> 2 pointers to find the sum 
        solution 2 -> simple dict 
        solution 3 -> binary search to find the other 
https://leetcode.com/problems/generate-parentheses/solution/
    what's cool -> learn how to keep track of parentheses
    approach 1 -> keep add ( or ) to explore all possibilities, base case check if it's valid to add to 'res'
        speed -> 
    approach 2 -> backtracking. add all ( 
        speed -> need to read 
    approach 3 -> look in comment for explanation




### sum
https://leetcode.com/problems/3sum/discuss/725950/Python-5-Easy-Steps-Beats-97.4-Annotated
    what's cool -> they have to turn list to tuple for hashable 
    almost do it myself, i have correct concept


############## ENCODING, SERIALIZATION 
https://www.lintcode.com/problem/659/description 
    explain -> turn list into string, and string can be sent over network much easier, then decode 




############## LINKED LIST  
### general 
https://leetcode.com/problems/merge-two-sorted-lists/ do it myself 
    how to do -> keep comparing 
https://leetcode.com/problems/linked-list-cycle do it myself
    how to do -> use fast and slow pointers 

https://leetcode.com/problems/remove-nth-node-from-end-of-list

https://leetcode.com/problems/reorder-list
    my try -> fast go to near last element (not last but we need to severe the next pointer). slow will replace next will fast.next -> failed cause too long 
    https://leetcode.com/problems/reorder-list/discuss/801971/Python-O(n)-by-two-pointers-w-Visualization
        solution 1 -> turn into array to make manipulation much easier. go spiral just like the image 
        solution 2 -> split into mid, match first half with reversed second half -> cool technique to get mid point
https://leetcode.com/problems/add-two-numbers/
    my try 1160/1568 
    what's cool : many edge cases. 
    https://leetcode.com/problems/add-two-numbers/discuss/1835217/Python3-DUMMY-CARRY-(-**-)-Explained 
        same concept but better soilution
        how to do : keep adding value as traversing, and have 'carry'




############### TWO POINTERS 
### 2 pointers 
https://leetcode.com/problems/container-with-most-water/ do it myself 
    how to do -> two pointers start, end. We are greedily getting max so the Bar smaller will be removed
    my try -> hard to deal with edge case where same bar length -> actually that edge case doesn't matter cause we will always use Lesser Height Bar to calculate
    what's interesting -> Water 
    time -> O(n) to walk all of them
    space -> O(1) no data 

https://leetcode.com/problems/remove-nth-node-from-end-of-list/
    # thought process
    # fast reaches the end
    # slow reaches size-n
#### sliding window
https://leetcode.com/problems/find-all-anagrams-in-a-string/
https://leetcode.com/problems/minimum-window-substring/ hard
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
    explain -> we only need to buy once, and sell once 
    how to do -> discuss/884314 is the standard state machine 
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/1735550/Python-Javascript-Easy-solution-with-very-clear-Explanation
        how to do -> 2 pointers. left sell, right buy. if sell > buy, then we move left 
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39049/Easy-O(n)-Python-solution
        how to do -> min_price is the lowest possible buying price in the array BEFORE price
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/884314/Python-3-greater-Very-simple-solution.-Explanation-added 
        how to do -> a little like state machine 
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/273395/Python-Greedy
        how to do -> a little like state machine too
    https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/1144842/Several-solutions-in-Python
        kadane's algorithm


https://leetcode.com/problems/longest-substring-without-repeating-characters/ do it myself
    how to do -> first get window, then keep moving/ expanding window 
    speed -> get all char O(n), worst case we have to pop n-1 character. And we only pop it once so it's O(2n)
    space -> worst case set is O(n)
    what's cool -> i don't need 'queue', instead i use 'firstIdx'
    https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1074783/Python-Interview-Thought-Process%3A-O(2n)-greater-O(n)
        how to do -> same idea, but better. base case get window. use queue to keep popping until same. 

https://leetcode.com/problems/permutation-in-string do it myself 
    my try -> did not regconize this is 'sliding window' so have a lot of troubles with edge case 
    speed -> first dictionary is O(s1), second dictionary is O(s2), and we have to keep compare dicitonary and ...
    space -> 2 dictionary so O(s1+s2)
    https://leetcode.com/problems/permutation-in-string/solution/
        approach 4 -> 
            what's cool -> store occurences in array s1map[s1.charAt(i) - 'a']++;
            how to do -> instead of using dictionary, we store occurences in array. 2 loop, for each word, we loop s1 length 
        approach 5 -> sliding window ...
        approach 6 -> optimized sliding window ... 


            




############### DICTIONARY or HASHMAP
aa

############### MATH 
https://leetcode.com/problems/basic-calculator
    # https://leetcode.com/problems/basic-calculator/discuss/546092/Simple-Python-Solution-using-stack-with-explanation-inline
    # Simple Example: 2 - 3
    # Initially res will have 2,i.e. res = 2
    # then store '-' in sign. it will be used when 3 comes. ie. sign = -1
    # Now 3 comes => res = res + num*sign
    # for (, move to stack
    # for ), 2-(3+4), Here res=3, num=4, sign=1 stack [2, -]     
https://leetcode.com/problems/2-keys-keyboard/solution/
    code -> all prime numbers input is same output. if can be divided by 'd' do it, increase 'd', until reaches prime number
    how to do -> basically (CPP)(CPPPPP) it's prime 3*5
https://leetcode.com/problems/string-to-integer-atoi/solution/ redo
    approach 1 ->
    approach 2 -> 
    Deterministic Finite Automaton -> 
    TOC (Theory Of Computation) -> state machines either transition to new stay or stay the same. 



############### BINARY SEARCH 
a

### general 
https://leetcode.com/problems/binary-search/ 
https://leetcode.com/problems/search-a-2d-matrix/ do it myself 1 hours with failed submissions 
    how to do -> binary search which row, and later binary search which column of that row 
    https://leetcode.com/problems/search-a-2d-matrix/discuss/26201/A-Python-binary-search-solution-O(logn)
        how to do -> 
    https://leetcode.com/problems/search-a-2d-matrix/discuss/1175274/Find-what's-difficult-in-a-problem-and-think-how-to-get-rid-of-it
        how to do -> 
https://leetcode.com/problems/koko-eating-bananas/
    my try -> I come up with brute force and a little binary search, but too scared to implement it
    why this pattern -> cause left too smal, right too big but can be right 
    https://leetcode.com/problems/koko-eating-bananas/solution/
        appproach 1 : brute force so it's not expected to pass all test cases. basically trying all options of 'k'
        appproach 2 : 
            how to do -> binary search with speed, base case left = right we stop and return
            what's cool -> they don't need to sort the array, they only need left, right, hours_spent 
            speed -> O(n) for traverse whole array each seach. O(logm) with m as maximum number of banana in a pile, so we have to binary search 1 to m -> total O(n*log(m))
            space -> O(1)

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array
    what's cool ->
        maybe don't think of examples, think abstract increase->decrease->increase
    https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/solution/
        approach 1 -> binary search. only compare 'mid' and '0'
https://leetcode.com/problems/median-of-two-sorted-arrays/
    what's hard -> i gave up when i see 'Hard' 
    https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/798913/Python-Simple-Two-Pointer-Solution-Time%3A-O(n%2Bm)-Space%3A-O(1)
        what's cool -> Hard problem but easy approach  
        how to do -> two pointers. combine lengths of both lists to LEN. traverse, get list1 if list1 item is smaller, get until we reach LEN//2 
    https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2511/Intuitive-Python-O(log-(m%2Bn))-solution-by-kth-smallest-in-the-two-sorted-arrays-252ms
        how to do ->



############### DYNAMIC PROGRAMMING GUIDE 
### dynamic programming guide
use DP whenever you have to make 'choices'
top-down with memoization : recursion 
bottom-up with tabluation : tabulation
If all subproblems must be solved at least once, bottom-up better



patterns 
    greedy
        greedy is a specific kind of DP, and DP is a general greedy.
    0/1 knapsack 
    unbounded knapsack 
    fib
    1D dynamic programming 
    2D dynamic programming
    Minimum (Maximum) Path to Reach a Target
        min to reach a target -> Coin Change
    Distinct Ways : distinct ways to reach target -> Unique Path 
    Merging Intervals : given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.
    palindromic subsequence : given two strings s1 and s2, return some result
    longest common substring  : given two strings s1 and s2, return some result
    Decision Making/ State Machine : Buy Sell Stock
    



### dynamic programming guide 
#https://www.youtube.com/watch?v=r4-cftqTcdI&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=25
SRTBOT sub-problems, relations, topological order, base case, original problem, and time. // check blackboard on video 
DP = recursion + memo
memoization : remember and reuse 
DAG shortest path 30:00
// stop 31 

#freecodecamp
algorithm whiteboard is hard, translating it into code is the hard part
students have habit of picture something in their mind
base cases don’t branch anymore
try to find familiar in new problem
fib
    time O(2^n)
    dp time O(2n)
gridTraveller memoization
    // stop 41

#https://www.youtube.com/watch?v=mBNrRy2_hVs&s
longest common subsequence





############### DYNAMIC PROGRAMMING CODE 
### general
https://leetcode.com/problems/maximum-subarray/ do it myself 
    how to do -> if number before is negative, remove them 
https://leetcode.com/problems/pascals-triangle/ do it myself
    how to do -> 
https://leetcode.com/problems/race-car/
    https://leetcode.com/problems/race-car/discuss/762584/Python-C%2B%2B-3-Simple-Steps-(BFS) 
        what's cool -> Race-car is a BFS problem, since we are given a target and have to find the shortest distance to reach there
        how to do -> 
            always move forward 
            only consider changing the direction if 2 conditions : drive pass and go furthur, go back and go way back 
            then ...

    https://leetcode.com/problems/race-car/discuss/1512080/Greedy-Approach-oror-Normal-conditions-oror-94-faster-oror-Well-Coded
        similar idea to above solution 





### greedy
guide  
    dp use previously computed results, greedy don't



### 0-1 knapsack either pick or don't pick
https://leetcode.com/problems/maximum-profit-in-job-scheduling/ binary search with dynamic programming knapsack bounded. 
    # https://leetcode.com/problems/maximum-profit-in-job-scheduling/discuss/996255/Python-using-DP-%2B-Binary-Search-(not-using-bisect-built-in)
    # 2 problems 0-1 knapsack and non overlapping 
    # sorted by endTime
    # binary search with (dpEndTime, start) as (right, target), find nonoverlapping time
    # dp -> if it's bigger profit, add endTime and add profit 

### 0/1 bounded knapsack items can't be repeated
https://leetcode.com/problems/partition-equal-subset-sum/
    https://www.youtube.com/watch?v=IsvocB5BJhw 6:00 very good O(n) analyze, last minute also have optimization

### unbounded knapsack
guide 




### minimum/ maximum path to reach a target
https://leetcode.com/problems/coin-change do it myself, unbounded knapsack
https://leetcode.com/problems/minimum-path-sum/ do it myself 
    how to do -> update matrix in-place with previous 
    https://leetcode.com/problems/minimum-path-sum/discuss/825410/Python3-Dynamic-Programming-90-w-Explaination small things but can improve big O
https://leetcode.com/problems/minimum-falling-path-sum/ do it myself
    how to do -> update matrix 
https://leetcode.com/problems/minimum-cost-for-tickets do it myself, unbounded knapsack  
    how to do -> each 'days', we buy 1-day 7-day and 30-day. Some days maybe not optimized but we only need last day.
    took me 4 hours -> 2 algorithm wrong, 358 wrong, and 'continue' wrong
    approach 1 -> recursion bottom-up go over everything 
    approach 2 -> ...
    https://leetcode.com/submissions/detail/727138197/ best overall, current = current-1 7 30 or 0
https://leetcode.com/problems/perfect-squares
    my try -> 225 / 588 because i used brute force even with memo
    https://leetcode.com/problems/perfect-squares/discuss/275311/Python-DP-and-BFS
    solution 1 -> Build up tabulation using min. relation is dp[i-j*j] so not [i-1] or [i-2]
    solution 2 -> BFS. layer. 
https://leetcode.com/problems/triangle/ do it myself in 40 minutes 
    how to do -> normal Minimum Failing Path but with Triangle 
    my try -> i tried 'directions' technique but it was messy



### distinct ways 
guide 
    2 pointers moving forward
https://leetcode.com/problems/unique-paths do it myself
https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/discuss/355894/Python-DP-with-memoization-explained


### merging intervals 
guide
    keep removing min/ max of intervals
https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/1510611/Greedy-Approach-oror-97-faster-oror-Well-Explained 
    # how to do : non-leaf is product of biggest leaves, sum is all non-leaf, find min sum -> just greedy 
    # code -> with min leaf node, we calculate non-leaf and add it to sum, then remove min.

https://leetcode.com/problems/unique-binary-search-trees/discuss/31761/Python-with-explanation.-I-guess-you-could-call-this-%22DP%22...
    # how to do -> go from 1->n with 'i' as middle. loop 'middle' and all combinations of left * combinations of right
    # my try -> i figure out some solutions, but i pass whole left array rather than left index. I did not figure out the relation 


### decision making (State Machine, a type of 0/1 knapsack)
guide
    draw state machine 

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/803206/PythonJSGoC%2B%2B-O(n)-by-DP-w-Visualization redo, knapsack 0/1, decision making
    # cur_hold : we bought and waiting to sell 
    # everytime we buy something it's negative 
    # either we buy it previously, or we buy current price
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking) 
    # s1 : did buy, can sell
    # best example of State Machine
https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/
    # what to do if better prices 10 later
    # -> basically the more buy/ sell the better
    # -> remeber we don't sell yet, we only testing which one better
    # -> most importantly, we buy 1 sell at 9, immediately buy that 9 again and it's not that good
        
### dp on strings I palindromic subsequence 
guide
    expand from small precomputed to bigger. use left, right pointers and know the differences of odd and even
https://leetcode.com/problems/palindromic-substrings do it myself 128/130 cases 
    use precomputed palindrom to compute larger palindrom 
    https://leetcode.com/problems/palindromic-substrings/discuss/392119/Solution-in-Python-3-(beats-~94)-(six-lines)-(With-Detaiiled-Explanation)
        # expand around center. 
        # (b - a - 1) is length of palindrome
        # length of palindrome has a pattern to predict how many palindrom with the same center inside (L+1)//2
        # (b-a)//2 is total palindrome  
        # for a,b in [(i,i),(i,i+1)] palindrom can be center in middle (odd) and center with 2 medians (even)
https://leetcode.com/problems/longest-palindromic-substring/ redo 



### dp on strings II longest common subsequence
guide
    2 pointers for 2 strings, then branch.
    or use tabulation. Only move bottom, right, or bottom right diagonally 
https://leetcode.com/problems/is-subsequence/
https://leetcode.com/problems/longest-common-subsequence/discuss/598508/Python-DP-solution-with-Explanation-%2B-Thinking-process-%2B-Diagram
    DP on strings by move forward 2 pointers
    0/1 knapsack 



############## prefix sum 
guide
    prefix sum : is the sum of all previous index



############### MATRIX
### guide 
rotate zip() -> list(zip(*matrix))
rotate reverse -> matrix[::-1]
rotate counter clock-wise -> (list(zip(*matrix)))[::-1]
https://leetcode.com/problems/spiral-matrix/


### general
https://leetcode.com/problems/valid-sudoku/ do it myself in 30 minutes
    how to do -> brute force check 3 different things
    what's cool -> i douby myself and don't even think my brute force will work 
    https://leetcode.com/problems/valid-sudoku/discuss/729180/Python-solutions-or-Single-Traversal-or-Single-Dictionary
        how to do -> add position of all occurences of a number. Then check if (same row) or (same column) or (same box)
        what's cool -> do 3 checks with single traversal 
    https://leetcode.com/problems/valid-sudoku/discuss/511365/Simple-Intuitive-Python-Approach
        how to do -> array of set, 'k subbox' with 9 areas 
        what's cool -> array of set 

### BFS 
https://leetcode.com/problems/number-of-islands/ do it myself  
https://leetcode.com/problems/rotting-oranges do it myself 







############### Graph

### guide 
https://leetcode.com/discuss/study-guide/1326900/graph-algorithms-problems-to-practice
    complete path : there are direct edges betwee any pairs of vertices  
    connected graph : can get from every vertices to another vertices through a series of edges (path)
    weighted graph : edges with number (weight)
    Dijkstra's algorithm : finding the shortest paths between nodes in a graph
    union-find : check ### -> help find numbers of connected components
    minimum spanning tree : check ###
    topological sort : linear ordering from vertext u to v, and u comes first
    Bellman Ford : for weighted graph, calculate shortest path from a single source vertext to all others
    Floyd Warshall : for directed weighted graph, finding shortest paths with positive of negative edge weights 
    Eulearian Path : finds a path that uses every edge in a graph only once.
    maximum network flows 
    biparte matching 




dfs patterns
    possible paths/permutations/ways.., then its dfs+back tracking
    lowest common ancestor 

bfs patterns 
    On the other hand, if the question is like shortest path and the graph is not weighted, use bfs




### general 
https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/
    we have group
    match element of other group to remaining groups
    (2,3) same as (3,2)
    my try -> I don't remember how to buildgraph or traverse adjancency list
https://leetcode.com/problems/find-the-town-judge do it myself 
    my try : find all 'potential judge' and check them later -> take too long to check them later

https://leetcode.com/problems/surrounded-regions/ do it myself in 30m
    how to do : 
        get all border O 
        4-directions that border
        if they are in 4-directions, add it to NONCHANGING set 
        then traverse matrix to change all CHANGING SET 
    speed : get all border O(logn) + bfs O(n) + last loop O(n)
    space : borderZero logn + nonchanging n + visited n O(n)
    SPEED and SPACE : check Discord, because it will grow according O(border) which is O(square(total element))

https://leetcode.com/problems/redundant-connection/ do it myself in 30m
    how to do : 
        run intially to collect all nodes 
        keep remove edges, and see if we can still reach all 
        (keep removing the last edges, if we can reach all, than return True immediately)  
    speed : initial loop O(edges) and for each edges, run entire edges again O(edges*edges)
    space : 
    approach 1 -> look at comment. Doing Cycle Prevention, build a graph one edge at at time, if there already a path, then the new edge will create cycle 
    approach 2 -> 
    https://leetcode.com/problems/redundant-connection/discuss/1295728/JS-Python-Java-C%2B%2B-or-Simple-Union-Find-Solution-w-Explanation
    solution 1 -> look at comment from my submission

https://leetcode.com/problems/clone-graph/
    how to do : 
        dictionary to make sure you store correct cloned node, and can be reuse -> very creative 
https://leetcode.com/problems/pacific-atlantic-water-flow/
    my try -> i only go 2-directions so it's wrong, i did not understand questions correctly, i also only traverse matrix normally 
    https://leetcode.com/problems/pacific-atlantic-water-flow/discuss/543988/Easy-understand-DFS-solution-beat-97
        how to do ->
            loop 4 borders, dfs, if newR newC is bigger than current then we keep dfs
        lesson -> with dfs, we don't need to worry about which row, column comes first 
        
############### Dijkstra algorithm
### guide 
Dijkstra's algorithm : shortest path from one node to every other nodes  
    step 1 -> priority queue with distance_from_source, and node 
    step 2 -> init distance to infinity 
    step 3 -> pick node with smallest distance, consider its neighbours
/network-delay-time uses all 3 patterns 
https://leetcode.com/list/53js48ke/ 
https://www.youtube.com/watch?v=XB4MIexjvY0
    Dijkstra is greedy
    can work on directed, undirected graph 
    relaxation : update vertex's cost 
    also work with negative weights


### general 
https://leetcode.com/problems/network-delay-time/solution/
    approach 1 -> dfs. 
    approach 2 -> bfs queue. 
    approach 3 -> priority queue. Dijkstra.
        TODO 
        time -> O(N+ElogN)
        space -> 



############### Bellman-Ford
### guide 
Bellman-Ford algorithm
    similar to BFS 
why use Bellman-Ford -> because it has at most 'k' stops
speed -> O(Edges*k)
it can deal with negative weights

### general
https://leetcode.com/problems/cheapest-flights-within-k-stops
    https://www.youtube.com/watch?v=5eIK3zUdYmE 
        what's cool -> traverse graph without using adjancency list or neighbours
        how to do -> 
            have prices[] and temp[]
            first layer k=0, prices[B] is infinity, temp[B] is 100. We still use infinity so temp[C] will have the bad 500 value
            update prices[] with temp[]
            second layer k=1, go all nodes of the graph again, this time prices[B] = 100 so we use that to calculate temp[C] = 200
        time -> 
            with k stops. 





############### MINIMUM SPANNING TREE
### guide
spanning tree : given undirected, connected graph G. Spanning tree is a subgraph of G, includes all vertices with min possible number of edges 
minimum spanning tree : 
    spanning tree with weights, sum of the weights of edges is as min as possible 
    if n vertices, n-1 edges 
Prim's Algorithm : 
    programiz.com/dsa/prim-algorithm great website 
    greedy algo
    start with smallest edges
    keep adding smallest edges to previous 
Kruskal's Algorithm : 
    purpose -> detect cycle
    greedy algo 
    start with smallest edges 
    get smallest edges, but it doesn't need to connect with previous 
    if new edge forming a cycle, don't 
    speed O(n^2)
    with min heap it's O(nlogn)


############### UNION FIND 
###guide
https://www.youtube.com/watch?v=ayW5B2W9hfo
    union find (disjoint set)
    union find are useful in graph problem
    each union has a representaitive, as tree root
    find(4) = root
    union(1,2) merge find(1) and find(2)
https://www.youtube.com/watch?v=wU6udHRIkcc
    weight and rank is better 
    disjoint set : sets that dont connect
    detecting cycles ->
        set have (1,2,3), for (1,3) edge, 1 and 3 already in set, so don't include this edge or we will have cycle
        if different set, perform Union()
    graph representation -> Union() keep adding set
    array representation -> 
        value -2 is parent 
        value n will have n as parent 
        value more negative is a bigger parent 
    collapsing find
        make all nodes link with the root parent 



############### TOPOLOGICAL  
### guide 
https://www.youtube.com/watch?v=eL-KzMXSXXI
    topological ordering -> in directed graph, ordering of nodes so that for A->B, print node A first 
    topological sort -> can find topological ordering in (V+E) time 
    directed cycle : can't have topological 
    directed acycle graph : don't have cycle 
    Tarjan's strongly connected component algorithm : detect if there are cycles 
    algo ->
        pick unvisited node 
        DFS 
        get leaf node first, and then reverse order  
    algo ->
        get leaf node
        then backtrack 
### general 
https://leetcode.com/problems/course-schedule
    https://leetcode.com/problems/course-schedule/discuss/58586/Python-20-lines-DFS-solution-sharing-with-explanation look at first comment 
    how to do dfs ->
        graph[take these after] = [prerequisites]
        3 states not visited, currently visiting, and visisted 
        visited is dictionary 
    https://leetcode.com/problems/course-schedule/discuss/441722/Python-99-time-and-100-space.-Collection-of-solutions-with-explanation
    how to do topological ->
        geeksforgeeks.org/topological-sorting-indegree-based-solution/ 
        0 incoming edges, incoming from prerequisites to course 
        1 vertex, with number of incoming edges 
        2 queue, with vertex with no incoming edges 
        3 



############### BINARY TREE
### general
https://leetcode.com/problems/invert-binary-tree/ do it myself 
    what's cool -> passing node reference 
https://leetcode.com/problems/maximum-depth-of-binary-tree do it myself 




### bfs
https://leetcode.com/problems/binary-tree-level-order-traversal do it myself but take 1 hint and 2 hours
    https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/458315/Python-99-speed-100-memory-*Simple-Solution*-with-comments memorize this, how to get all elements of that one level
https://leetcode.com/problems/binary-tree-right-side-view/ do it myself 
    speed O(n) since we have to traverse all nodes 
    space O(logn) because only need to store right-hand  
    https://leetcode.com/problems/binary-tree-right-side-view/discuss/56064/5-9-Lines-Python-48%2B-ms much faster code

### dfs
https://leetcode.com/problems/find-duplicate-subtrees do it myself, with 5 hours and bad big O
    https://leetcode.com/problems/find-duplicate-subtrees/discuss/1571352/Python-solution-explained-in-two-steps-for-beginners serialize postorder, put it in dict, if duplicated in dict then it's result 
    https://leetcode.com/problems/find-duplicate-subtrees/discuss/1178526/Easy-%2B-Clean-%2B-Straightforward-Python-Recursive simple dfs, print 'sub' to understand 
    https://leetcode.com/problems/find-duplicate-subtrees/discuss/106020/Python-easy-understand-solution inorder can create same serialization for symmetric trees

### serialize
https://leetcode.com/problems/serialize-and-deserialize-binary-tree/






############### BINARY SEARCH TREE
### basic 
https://leetcode.com/problems/validate-binary-search-tree do it myself
https://leetcode.com/problems/kth-smallest-element-in-a-bst do it myself
    # approach 1 : use Stack for traversal, and also stop at k -> Speed is O(H+k), H can be balanced tree or skewed tree
    # approach optimized : (do it late) 

############### DICTIONARY
https://leetcode.com/problems/lru-cache/ do it myself
    how to do -> OrderedDict which tracks the orders of inserted key
    https://leetcode.com/problems/lru-cache/discuss/850110/Python-3.7%2B.-No-need-to-use-OrderedDict.-Simply-use-the-regular-dict
        how to do -> no need to use OrderedDict
    https://leetcode.com/problems/lru-cache/discuss/594885/Python-Simple-implementation-with-deque-(slow)-and-OrderedDict-(fast)
        how to do -> deque 
        

############### STACK 
###guide
can implemented with list, collections.deque, queue.LifoQueue

### general
https://leetcode.com/problems/valid-parentheses do it myself
### bar
https://leetcode.com/problems/trapping-rain-water do it myself, second hard problem I solved
    my try : monotonic stack with first bar as max. loop all height. At the end, when first bar is actually max then we do more computation.
        speed : O(n) + O(n)
    approach 1 : brute force for each bar, check with both sides 
        speed O(n^2) cause traverse*traverse
    approach 2 : find max height from left-end view, right-end view. Then use min()
        speed O(n) cause 2 for-loop, then last min for-loop
        space O(n)
    approach 3 : Stack  
        monotonic decreasing bar 
        if newBar is bigger. We have 3 vairables (newBar as bound right, newly popped stack waterArea, and top of the stack as bound left)
        distance * min(bound right, bound left)
        then we add newBar to stack 
        speed -> O(n)
    approach 4 : 2 pointers
        for any Bar, there are always 2 Borders max_left and max_right
        if we are going from left-to-right, then we alwaysk now what is max_left 
        vice versa for right-to-left 
        but we have height[left] < height[right] : left_pointer += 1
        for example -> if last Bar is highest, then max_right is last bar and we will keep moving left_pointer
        speed -> O(n) cause single iteration
    approach 5 : https://leetcode.com/problems/trapping-rain-water/discuss/17528/Easy-to-understand-Python-10-line-60ms-O(n)
        over-fill left max, then drain on right min
    https://leetcode.com/problems/trapping-rain-water/discuss/1005489/Python-Two-pointer-approach-with-explanation-O(n)-time-O(1)-space
        approach 3 but in Python



https://leetcode.com/problems/largest-rectangle-in-histogram/
    # approach 1 Stack https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/452612/Thinking-Process-for-Stack-Solution
        # why Stack -> because bars are in order
        # because of bar 1, bar 2 is useless because max height is 1  
        # don't understand how he calculates width -> (look at code, not tutorial)
        # i−stack[−1]−1 is newestIndex - top index in the stack (after popping 6)
    # approach 2 DP https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/440433/Python-Detailed-Explanation-for-DP-O(n)-Solution-Beats-99.9-RunTime-100-Memory
        # 
https://leetcode.com/problems/daily-temperatures do it myself 
    my try -> some algo error, use list for stack so it's slow 
    approach 1 -> monotonic stack, same as mine 
    approach 2 -> go backward in 'temperatures'. if it's hottest, update 'hottest', if it's smaller, use 'result' to compute -> it's faster because approach 1 Stack have to go forward, then go backward.

https://leetcode.com/problems/car-fleet
    my try : too many variables, should have zip() and sorted() to simplify 
    https://leetcode.com/problems/car-fleet/discuss/255589/Python-Code-with-Explanations-and-Visualization-Beats-95
        how to do ->
            dist/vel is the key
            dist/vel is to calculate ideal arrival time. If new car has smaller ideal arrival time than Top Stack, meaning it's faster and we ignore it, incrase 'fleet' by 1 
    https://leetcode.com/problems/car-fleet/discuss/1299193/Python-Greedy-pattern-explained
        nice DP explanation for pattern "allocating resources to overlapping events"
        how to do -> 
            similar to above ...





############### HEAP  
https://leetcode.com/problems/kth-largest-element-in-a-stream/discuss/482591/Simple-Python-Solution-or-Maintain-Min-Heap-whose-size-is-always-kept-at-k
    my try -> pass 9/10 but time limit exceed 


https://leetcode.com/problems/merge-k-sorted-lists do it myself using brute force
    # approach 2 : compare between k pointers, which one is smaller go to 'res' linked list 
    # approach 3 : optimized approach 2 with priority queue. optimized the comparison process. 
    # approach 4 : merge lists one by one
    # approach 5 : optimized approach 4, merge by divide and conqueor 
https://leetcode.com/problems/find-median-from-data-stream/discuss/74047/JavaPython-two-heap-solution-O(log-n)-add-O(1)-find
    # first half max heap to the front, second half min heap to the front
    # [] and [6]
    # [-6] and [10]
    # [-2] and [6, 10]

https://leetcode.com/problems/top-k-frequent-elements/ do it myself 
    how to do -> dict then heap 
    speed -> pop heap k times O(klogn), read everything into dict O(n)
    https://www.youtube.com/watch?v=YPTqKIgVk-k BUCKET SORT 
        how to do O(klogn) -> use heap
        how to do O(n) ->
            bucket sort // 3:40
    https://leetcode.com/problems/top-k-frequent-elements/discuss/484980/Python-Explained-Two-Simple-Heap-solutions 
        how to do -> if it's over k, then pop min


############### BACKTRACKING
### guide 
zero padding : can't be just 1, has to be 0001
backtracking is about exploring all possible outcomes, if the outcome is not desirable we go back
steps to solve pattern ->
    /subset has great backtracking solution
    choose -> recursive what 
    constraint -> 
    goal -> 
https://www.geeksforgeeks.org/backtracking-introduction/
    back tracking algorithm is not as good as DP or Greedy, but there are cases when backtracking is great 
    can be used for Knapsack problem

### general 
https://leetcode.com/problems/permutations/ do it myself 
    https://leetcode.com/submissions/detail/719236963/ normal recursion 
    https://leetcode.com/problems/permutations/discuss/360280/Python3-backtracking backtracking 

https://leetcode.com/problems/permutations-ii do it myself 

https://leetcode.com/problems/combination-sum/discuss/16510/Python-dfs-solution.
    very basic backtracking 
    how to do ->  
        backtracking - we need to explore all possibilities since they are no limit, we don't need to find min/max, and we can use 'input' multiple times
        just run it until 'target' is negative, that's wrong, if 'target' == 0 then add to 'result'



https://leetcode.com/submissions/detail/673764853/
    how to do ->
        similar to /combination-sum/ 
        base case if len(permutation) == len(input) then we are good 
        add all numbers with Set

https://leetcode.com/problems/subsets/ do it myself cascading
    approach 1 -> cascading. for every new number. add all new number to all previous list.
        time ->
        space ->  
    approach 2 -> backtracking. for expanding length. we add remaining number, backtrack, then add remaining number
        time -> O(N*2^n) I think it's O(Each Element * ...)
        space -> 
    approach 3 -> Lexicographic (Binary Sorted) Subsets
    https://leetcode.com/problems/subsets-ii/discuss/30305/Simple-python-solution-(DFS) DFS without using Set

https://leetcode.com/problems/n-queens/ do it myself. first hard problem.
    how to do ->
        recursive backtrack 
        when place a Queen, mark all 'attacked path' as forbidden. continue doing that 
    https://leetcode.com/problems/n-queens/discuss/19810/Fast-short-and-easy-to-understand-python-solution-11-lines-76ms
        what's cool -> check diagonally 
        how to do ->
            TODO : repeat learn 
            read the comment 
            recursively calculate board, each row have one, check for column/left diagonal/ right diagnoal -> build board later
            we are checking previous diagonally, so check 2 slopes left up -1 and right up +1 
            p + q same as y + x = b, look for b (y-intercept) cause we have m (slope)
            slope m is going up +1 or down -1
            p -> row number 
            q -> column number 
            xy_sum -> 
            xy_dif ->
    https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/ 
        how to do ->
            backtrack
https://leetcode.com/problems/palindrome-partitioning
    how to do -> backtracking with splicing [start:end] and get all possible combination of substrings 
    my try -> i can think of backtracking, even backtracking with DP. But my code is wrong 
    https://leetcode.com/problems/palindrome-partitioning/solution/
        approach 1 -> backtracking and DFS. same concept with mine.
            time complexity -> 
                total O(N*2^N)
                N is length of string
                O(2^N) for worst case keep having palindrome tree
                O(n) to generate each substring 
        approach 2 -> backtracking with Dynamic Programming. instead of isPalindrome(), we use DP() for palindrome 
            end - start <= 2 is ...
    ALL SUBMISSIONS 
        recursive without backtracking -> https://leetcode.com/submissions/detail/736764814/
        recursion with backtracking -> 
        recursion with DP https://leetcode.com/submissions/detail/736785203/ 




############### BITMASK and BIT MANIPULATION 
guide
The integers are first converted into binary and then operations are performed on bit by bit
bitmas 
    & AND 
    | OR 
    ~ NOT one complement 
    ^ XOR 
        if same, then it's 0 (false)
        if different, then it's 1
        if both are integer, XOR will compare each bit
    100 >> n right shift divide by 2**n
    100 << n left shift multiple by 2**n
technique
    n&(n-1) will remove the rightmost

operator overloading : same symbol, different meanings in different classes 
https://leetcode.com/problems/sum-of-two-integers/discuss/84278/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently
    a  


### general 
https://leetcode.com/problems/number-of-1-bits/discuss/1044775/Python-n-and-(n-1)-trick-%2B-even-faster-explained
    solution 1 -> keep removing rightmost until 'n' is zero (number of bit stay the same, only value of bit changed)
    solution 2 -> work with group of 2, then 4, then 8


############### TRIE 
### GUIDE 
trie (prefix tree) is type of tree, often for characters
store 'character' by storing as 'key' or  


### TRIE 
https://leetcode.com/problems/implement-trie-prefix-tree/ solve half of it myself
https://leetcode.com/problems/design-add-and-search-words-data-structure/


### CONTEST
5218. Sum of Numbers With Units Digit K not done 
https://leetcode.com/discuss/interview-question/1803238/Amazon-or-OA-or-sum-of-cache-optimization-power-for-all-sub-arrays
https://leetcode.com/problems/subtree-of-another-tree/discuss/386209/Python-98-speed-with-comments
https://leetcode.com/problems/most-common-word/solution/
https://leetcode.com/problems/group-anagrams/
https://leetcode.com/problems/valid-anagram/ do it myself
https://leetcode.com/problems/longest-repeating-character-replacement don't understand 
