### practice Big O 
cheatsheet 
    O(1) constant time 
    O(n) linear time 
    O(logn) : binary search. divide and conquer. a binary tree of 4-nodes has height log2(4)+1 = 3
    O(nlogn) : sort. a combination of O(n) * O(logn)
    O(n^2) : nested for-loop 
    O(n!) : with permutation or factorial 
    O(2^N) : subset


techniques 
    https://stackoverflow.com/questions/25216962/python-concatenation-vs-append-speed-on-lists
        list append is faster than concat 
    

###Big O
General     
https://cs.stackexchange.com/questions/83574/does-space-complexity-analysis-usually-include-output-space
    does-space-complexity-analysis-usually-include-output-space

https://wiki.python.org/moin/TimeComplexity
    O(n) for copy -> list.copy(), [:]

https://stackoverflow.com/questions/2307283/what-does-olog-n-mean-exactly
    yellow business, white people 

https://stackoverflow.com/questions/3953244/example-of-on
    O(n!) this is scale of O!, not exact factorial of a number



### AMORTIZE 
    about amortized time Big O,
    for ArrayList in Java, if we keep appending element to the end, that's O(1). But if we reach the ArrayList length limit, it will copy and create another ArrayList with twice the size and copy old list into new list, so it will be O(n)
    so amortized time is O(1)
    and normal (worst) time is O(n) right ?