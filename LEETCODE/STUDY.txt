############### FOR STUDYING, LATER WILL TURN IT INTO GUIDE  
OTHER
    Tarjan's strongly connected component algorithm : detect if there are cycles

Prim's 
    principals 
        keep getting smallest cost, the one attacehd with previous 
        time O((V+E)logV)
    algo 
        visit set() 
        frontier minHeap 
        res 
        choose a random node 
        put all neighbor (cost, node) to frontier 
        choose smallest, repeat
    problem 
        https://leetcode.com/submissions/detail/741291968/
            how to do -> build adjacency list, then Prim's 
            time -> O(n^2 logn) cause (n^2) is number of potential edges, and (logn) come from Prim's cause Min Heap 

Topological
    principals 
        when -> 
            only for Directed Acylic Graph (directed and no cycle)
            directed cycle : can't have topological 
            acycle graph : don't have cycle 
        purpose -> schedule system where first task comes before second task
        example -> 
            take 0 before 2, take 1 before 2 so [2,0] and [2,1]
            0->2 1->2
            topological sort prints the one with no incoming edges first 
    algo principal 
        print all node with no incoming edges first 
        meaning traverse adjacency list and have cycle(), visit() 
    algo 
        loop all nodes 
        we have output[], visit set(), cycle() 
        if it's not in this cycle yet, we add to cycle
        then dfs 
        then cycle, visit, output add current 

    problems 
        https://leetcode.com/problems/course-schedule-ii/
            you don't need to know topological sort, this problem teaches u that
            how to do -> read 'algo' above
            
        https://leetcode.com/problems/course-schedule do it myself in topological sorting 
            https://leetcode.com/problems/course-schedule/discuss/58586/Python-20-lines-DFS-solution-sharing-with-explanation look at first comment 
            how to do dfs ->
                graph[take these after] = [prerequisites]
                3 states not visited, currently visiting, and visisted 
                visited is dictionary 
            https://leetcode.com/problems/course-schedule/discuss/441722/Python-99-time-and-100-space.-Collection-of-solutions-with-explanation
            how to do topological ->
                geeksforgeeks.org/topological-sorting-indegree-based-solution/ 
                0 incoming edges, incoming from prerequisites to course 
                1 vertex, with number of incoming edges 
                2 queue, with vertex with no incoming edges 

        https://leetcode.com/problems/minimum-height-trees/ topological
            https://leetcode.com/problems/minimum-height-trees/solution/
                centroids : (similar to root node) node that is close to all the peripheral nodes (leaf nodes)
                approach 0 : brute force just all tree, then choose smallest 
                how to do ->
                    (keep trimming leaf ndoes until only 1 or 2 centroids left)
                    queue to holds all leaves, bfs 
                    keep removing leaves, there will be new leaves, keep removing all 
                complexity
                    e = v-1 
                    time -> buildGraph O(v), initial leaves O(v), O(v+e)
                    space -> buildGraph O(v+e) 

                    


                


            step base cases input only 2 nodes 
            step 1 -> get all leaves
            step 2 -> queue until only 2 nodes left. remove leaf from adjancency list (bi-directional). add new leaf.
        https://leetcode.com/problems/find-eventual-safe-states/ do it myself 
            how to do -> topological sorting, check if node's all neighborers are 'qualify' or not 
            time O(E+V) -> O(n) create adjList, O(E+V) 
            space O(3n) -> qualify, visit, adjList
            https://leetcode.com/problems/find-eventual-safe-states/solution/
                approach 1 -> Reverse Edges. 
                    how to do -> have outgoingGraph, incomingGraph. 
                    We start from Terminal Node and works backward, each time remove an edge from outgoingGraph, if outgoingGraph is None, it's 'qualify' too
                approach 2 -> 
                    ... 



             




https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/894031/Python-O(logn)-Detailed-Explanation     
    how to do ->
        split into 2 normal arrays, the others are 2 abnormal arrays 
    
https://leetcode.com/problems/largest-rectangle-in-histogram/
    how to come up with this solution ->

    how to do ->
        monotonic stack increasing 
        if we meet a smaller 'height'
        then we trace back, area = width * height. width is 'index', and height is smallest bar, which is the first one since this is monotonic stack

    https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/28917/AC-Python-clean-solution-using-stack-76ms
        how to do -> same as above 

https://leetcode.com/problems/robot-bounded-in-circle/ SIMULATION 
    https://leetcode.com/problems/robot-bounded-in-circle/discuss/850464/Python-3-or-Simulation-or-Explanation
        how to do ->
            north 0 
            west 1 

https://leetcode.com/problems/reverse-integer/


https://www.google.com/search?q=recruiting+event&oq=recruiting+event&aqs=chrome..69i57.3581j0j7&sourceid=chrome&ie=UTF-8&ibp=htl;events&rciv=evn&sa=X&ved=2ahUKEwj-odijyvH4AhXWlmoFHbTmBb8Q8eoFKAJ6BAgXEA8&sxsrf=ALiCzsbd8h6kwbr-8bpyA1n11dSXeDD7Zw:1657568077689#htivrt=events&htidocid=L2F1dGhvcml0eS9ob3Jpem9uL2NsdXN0ZXJlZF9ldmVudC8yMDIyLTA3LTI4fDQ2OTg0MTMxMDM4OTU1MDQ4OTg%3D&fpstate=tldetail

https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/ 
    what's cool -> sliding window SUM but have negative
    how to do ->
        (monotonic queue)
        don't use 'nums' input directly, use PrefixSum
        think about it, if >= k then we will make it <k for adding new number
        ....


https://leetcode.com/problems/subsets/
    speed ->
        input [1,3,2]
        000: []
        001: [2]
        010: [3]
        011: [3,2]
        100: [1]
        101: [1,2]
    bit manipulation ->
        N = 3
        Cap = 8
        Mask: 0, 1, 2, 3, 4, 5, 6, 7
        mask: 000, 001, 010, 011,100, 101, … 111
        Bit = 001, 010, 100,
        0: []
        1 = 001: [1]
        2 = 010: [3]
        3 = 011: [1,3]
        4 = 100: [2]
        …
        7 = 111 : [1,3,2]

